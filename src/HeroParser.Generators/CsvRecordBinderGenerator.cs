using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using static HeroParser.Generators.GeneratorHelpers;

namespace HeroParser.Generators;

/// <summary>
/// Source generator for CSV record binders.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class CsvRecordBinderGenerator : IIncrementalGenerator
{
    private const string GENERATED_NAMESPACE = "HeroParser.SeparatedValues.Records.Binding";
    private const string BINDER_TYPE = "global::HeroParser.CsvRecordBinder";
    private const string BINDER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Records.Binding.CsvRecordBinderFactory";
    private const string WRITER_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriter";
    private const string WRITER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriterFactory";

    private static readonly string[] generateAttributeNames =
    [
        "HeroParser.SeparatedValues.Records.Binding.CsvGenerateBinderAttribute",
        "HeroParser.CsvGenerateBinderAttribute"
    ];

    private static readonly string[] columnAttributeNames =
    [
        "HeroParser.SeparatedValues.Records.Binding.CsvColumnAttribute",
        "HeroParser.CsvColumnAttribute"
    ];

#pragma warning disable RS2008 // Enable analyzer release tracking - not needed for internal generator
    private static readonly DiagnosticDescriptor unsupportedPropertyTypeDiagnostic = new(
        "HERO001",
        "Unsupported property type",
        "Property '{0}' of type '{1}' is not supported by the CSV record binder generator. Supported types include primitives, DateTime, DateTimeOffset, DateOnly, TimeOnly, Guid, TimeZoneInfo, and enums.",
        "HeroParser.Generators",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);
#pragma warning restore RS2008

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Use ForAttributeWithMetadataName for better caching - register for both attribute names
        var provider1 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[0],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        var provider2 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[1],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        // Combine both providers
        var combined = provider1.Collect().Combine(provider2.Collect());

        // Generate per-type files for better incrementality
        context.RegisterSourceOutput(provider1, static (spc, descriptor) => EmitTypeSource(spc, descriptor!));
        context.RegisterSourceOutput(provider2, static (spc, descriptor) => EmitTypeSource(spc, descriptor!));

        // Generate registration file
        context.RegisterSourceOutput(combined, static (spc, tuple) =>
        {
            var all = tuple.Left.Concat(tuple.Right).Where(x => x is not null).ToList();
            if (all.Count > 0)
                EmitRegistration(spc, all!);
        });
    }

    private static TypeDescriptor? TransformToDescriptor(GeneratorAttributeSyntaxContext ctx, CancellationToken ct)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;

        if (symbol.IsAbstract || !IsTypeAccessible(symbol))
            return null;

        return BuildDescriptor(symbol, ct);
    }

    private static void EmitTypeSource(SourceProductionContext context, TypeDescriptor descriptor)
    {
        var builder = new SourceBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        // Report diagnostics for unsupported properties
        foreach (var diag in descriptor.Diagnostics)
        {
            context.ReportDiagnostic(diag);
        }

        context.AddSource($"CsvBinder.{descriptor.SafeClassName}.g.cs", builder.ToString());
    }

    private static void EmitRegistration(SourceProductionContext context, IReadOnlyList<TypeDescriptor> descriptors)
    {
        var builder = new SourceBuilder(8192);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();
        builder.AppendLine("file static class CsvRecordBinderGeneratedRegistration");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("[ModuleInitializer]");
        builder.AppendLine("internal static void Register()");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var descriptor in descriptors)
        {
            // Filter members for binder (those with setters)
            var binderMembers = GetMembersWithSetters(descriptor.Members);
            if (binderMembers.Count > 0)
            {
                EmitBinderRegistration(builder, descriptor.FullyQualifiedName, binderMembers);
            }

            // Filter members for writer (those with getters)
            var writerMembers = GetMembersWithGetters(descriptor.Members);
            if (writerMembers.Count > 0)
            {
                EmitWriterRegistration(builder, descriptor.FullyQualifiedName, writerMembers);
            }
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("CsvRecordBinderFactory.Registration.g.cs", builder.ToString());
    }

    private static List<MemberDescriptor> GetMembersWithSetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.SetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static List<MemberDescriptor> GetMembersWithGetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.GetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static void EmitBinderRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterGeneratedBinder(typeof({fullyQualifiedName}), options => {BINDER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {BINDER_TYPE}<{fullyQualifiedName}>.BindingTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {BINDER_TYPE}<{fullyQualifiedName}>.BindingTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeName}),");
            builder.AppendLine($"\"{member.HeaderName}\",");
            builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.SetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static void EmitWriterRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{WRITER_FACTORY_TYPE}.RegisterGeneratedWriter(typeof({fullyQualifiedName}), options => {WRITER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeName}),");
            builder.AppendLine($"\"{member.HeaderName}\",");
            builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.GetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static TypeDescriptor? BuildDescriptor(INamedTypeSymbol type, CancellationToken ct)
    {
        var members = new List<MemberDescriptor>();
        var diagnostics = new List<Diagnostic>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            ct.ThrowIfCancellationRequested();

            if (property.IsStatic)
                continue;

            var hasSetter = property.SetMethod is { DeclaredAccessibility: Accessibility.Public };
            var hasGetter = property.GetMethod is { DeclaredAccessibility: Accessibility.Public };

            if (!hasSetter && !hasGetter)
                continue;

            var mapAttribute = GetFirstMatchingAttribute(property, columnAttributeNames);
            var headerName = property.Name;
            int? attributeIndex = null;
            string? format = null;

            if (mapAttribute is not null)
            {
#pragma warning disable IDE0010 // Populate switch - intentionally not exhaustive
                foreach (var arg in mapAttribute.NamedArguments)
                {
                    switch (arg.Key)
                    {
                        case "Name" when arg.Value.Value is string s && !string.IsNullOrWhiteSpace(s):
                            headerName = s;
                            break;
                        case "Index" when arg.Value.Value is int i && i >= 0:
                            attributeIndex = i;
                            break;
                        case "Format" when arg.Value.Value is string f && !string.IsNullOrWhiteSpace(f):
                            format = f;
                            break;
                    }
                }
#pragma warning restore IDE0010
            }

            if (!IsSupportedType(property.Type))
            {
                diagnostics.Add(Diagnostic.Create(
                    unsupportedPropertyTypeDiagnostic,
                    property.Locations.FirstOrDefault() ?? Location.None,
                    property.Name,
                    property.Type.ToDisplayString()));
                continue;
            }

            var typeName = property.Type.ToDisplayString(FullyQualifiedFormatWithNullable);
            var headerLiteral = EscapeString(headerName);
            var formatLiteral = format != null ? EscapeString(format) : null;

            var setterFactory = hasSetter ? CreateSetter(typeName, type, property.Name) : null;
            var getterFactory = hasGetter ? CreateGetter(type, property.Name) : null;

            members.Add(new MemberDescriptor(
                property.Name,
                headerLiteral,
                attributeIndex,
                typeName,
                formatLiteral,
                setterFactory,
                getterFactory));
        }

        if (members.Count == 0 && diagnostics.Count == 0)
            return null;

        var fqName = type.ToDisplayString(FullyQualifiedFormatWithNullable);
        var safeClassName = CreateSafeClassName(type);
        return new TypeDescriptor(fqName, safeClassName, members, diagnostics);
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private static string CreateGetter(INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target) => target.{propertyName}";

    private sealed record TypeDescriptor(
        string FullyQualifiedName,
        string SafeClassName,
        IReadOnlyList<MemberDescriptor> Members,
        IReadOnlyList<Diagnostic> Diagnostics);

    private sealed record MemberDescriptor(
        string MemberName,
        string HeaderName,
        int? AttributeIndex,
        string TypeName,
        string? Format,
        string? SetterFactory,
        string? GetterFactory);
}
