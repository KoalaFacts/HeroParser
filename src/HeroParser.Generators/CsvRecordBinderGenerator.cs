using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace HeroParser.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class CsvRecordBinderGenerator : IIncrementalGenerator
{
    private const string GENERATED_NAMESPACE = "HeroParser.SeparatedValues.Records.Binding";
    private const string BINDER_TYPE = "global::HeroParser.CsvRecordBinder";
    private const string BINDER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Records.Binding.CsvRecordBinderFactory";
    private const string COLUMN_TYPE = "global::HeroParser.SeparatedValues.CsvCharSpanColumn";
    private static readonly string[] generateAttributeNames = ["HeroParser.SeparatedValues.Records.Binding.CsvGenerateBinderAttribute", "HeroParser.CsvGenerateBinderAttribute"];

    private static readonly string[] columnAttributeNames = ["HeroParser.SeparatedValues.Records.Binding.CsvColumnAttribute", "HeroParser.CsvColumnAttribute"];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (ctx, _) =>
                {
                    if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) is not INamedTypeSymbol symbol)
                        return null;

                    return HasGenerateAttribute(symbol) ? symbol : null;
                })
            .Where(x => x is not null)
            .Select((symbol, _) => symbol!)!;

        var collected = candidates.Collect();

        context.RegisterSourceOutput(collected, static (spc, symbols) => Emit(spc, symbols!));
    }

    private static void Emit(SourceProductionContext context, IReadOnlyList<INamedTypeSymbol> symbols)
    {
        if (symbols.Count == 0)
            return;

        var builder = new SourceBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();
        builder.AppendLine("file static class CsvRecordBinderGeneratedRegistration");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("[ModuleInitializer]");
        builder.AppendLine("internal static void Register()");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var symbol in symbols)
        {
            if (symbol is null || symbol.IsAbstract)
                continue;

            var descriptor = BuildDescriptor(symbol);
            if (descriptor is null)
                continue;

            builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterGeneratedBinder(typeof({descriptor.FullyQualifiedName}), options => {BINDER_TYPE}<{descriptor.FullyQualifiedName}>.CreateFromTemplates(options, new {BINDER_TYPE}<{descriptor.FullyQualifiedName}>.BindingTemplate[]");
            builder.AppendLine("{");
            builder.Indent();

            foreach (var member in descriptor.Members)
            {
                builder.AppendLine($"new {BINDER_TYPE}<{descriptor.FullyQualifiedName}>.BindingTemplate(");
                builder.Indent();
                builder.AppendLine($"\"{member.MemberName}\",");
                builder.AppendLine($"typeof({member.TypeName}),");
                builder.AppendLine($"\"{member.HeaderName}\",");
                builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
                builder.AppendLine($"{member.ConverterFactory},");
                builder.AppendLine($"{member.SetterFactory}),");
                builder.Unindent();
            }

            builder.Unindent();
            builder.AppendLine("}));");
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("CsvRecordBinderFactory.g.cs", builder.ToString());
    }

    private static TypeDescriptor? BuildDescriptor(INamedTypeSymbol type)
    {
        var members = new List<MemberDescriptor>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (property.IsStatic || property.SetMethod is null || property.SetMethod.DeclaredAccessibility != Accessibility.Public)
                continue;

            var mapAttribute = GetFirstMatchingAttribute(property, columnAttributeNames);
            var headerName = property.Name;
            int? attributeIndex = null;
            if (mapAttribute is not null)
            {
                foreach (var arg in mapAttribute.NamedArguments)
                {
                    if (arg.Key == "Name" && arg.Value.Value is string s && !string.IsNullOrWhiteSpace(s))
                        headerName = s;
                    if (arg.Key == "Index" && arg.Value.Value is int i && i >= 0)
                        attributeIndex = i;
                }
            }

            var converter = CreateConverter(property);
            if (converter is null)
                return null; // unsupported type -> skip generation for this type

            var typeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            var headerLiteral = headerName.Replace("\"", "\"\"");

            members.Add(new MemberDescriptor(
                property.Name,
                headerLiteral,
                attributeIndex,
                typeName,
                converter.Factory,
                CreateSetter(typeName, type, property.Name)));
        }

        if (members.Count == 0)
            return null;

        var fqName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        return new TypeDescriptor(fqName, members);
    }

    private static ConverterDescriptor? CreateConverter(IPropertySymbol property)
    {
        var type = property.Type;
        var isNullable = type.NullableAnnotation == NullableAnnotation.Annotated || type.IsReferenceType;
        var underlying = type is INamedTypeSymbol named && named.IsGenericType && named.Name == "Nullable" ? named.TypeArguments[0] : type;

        string? body = underlying.SpecialType switch
        {
            SpecialType.System_String => isNullable
                ? "if (column.IsEmpty) { value = null; return true; } value = column.ToString(); return true;"
                : "value = column.ToString(); return true;",
            SpecialType.System_Int32 => BuildTryParse("column.TryParseInt32", isNullable),
            SpecialType.System_Int64 => BuildTryParse("column.TryParseInt64", isNullable),
            SpecialType.System_Int16 => BuildTryParse("column.TryParseInt16", isNullable),
            SpecialType.System_Byte => BuildTryParse("column.TryParseByte", isNullable),
            SpecialType.System_UInt32 => BuildTryParse("column.TryParseUInt32", isNullable),
            SpecialType.System_UInt64 => BuildTryParse("column.TryParseUInt64", isNullable),
            SpecialType.System_UInt16 => BuildTryParse("column.TryParseUInt16", isNullable),
            SpecialType.System_SByte => BuildTryParse("column.TryParseSByte", isNullable),
            SpecialType.System_Double => BuildTryParse("column.TryParseDouble", isNullable),
            SpecialType.System_Single => BuildTryParse("column.TryParseSingle", isNullable),
            SpecialType.System_Decimal => BuildTryParse("column.TryParseDecimal", isNullable),
            SpecialType.System_Boolean => BuildTryParse("column.TryParseBoolean", isNullable),
            _ => BuildComplexConverter(underlying, isNullable)
        };

        if (body is null)
            return null;

        var factory = $"({COLUMN_TYPE} column, out object? value) => {{ {body} }}";
        return new ConverterDescriptor(factory);
    }

    private static string? BuildComplexConverter(ITypeSymbol type, bool isNullable)
    {
        var display = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return type.ToDisplayString() switch
        {
            "System.DateTime" => BuildTryParse("column.TryParseDateTime", isNullable),
            "System.DateTimeOffset" => BuildTryParse("column.TryParseDateTimeOffset", isNullable),
            "System.DateOnly" => BuildTryParse("column.TryParseDateOnly", isNullable),
            "System.TimeOnly" => BuildTryParse("column.TryParseTimeOnly", isNullable),
            "System.Guid" => BuildTryParse("column.TryParseGuid", isNullable),
            "System.TimeZoneInfo" => BuildTryParse("column.TryParseTimeZoneInfo", isNullable),
            _ when type.TypeKind == TypeKind.Enum => BuildTryParse($"column.TryParseEnum<{display}>", isNullable),
            _ => null
        };
    }

    private static string BuildTryParse(string tryParseCall, bool isNullable)
    {
        if (isNullable)
        {
            return $"if (column.IsEmpty) {{ value = null; return true; }} if ({tryParseCall}(out var parsed)) {{ value = parsed; return true; }} value = null; return false;";
        }

        return $"if ({tryParseCall}(out var parsed)) {{ value = parsed; return true; }} value = null; return false;";
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private static bool HasGenerateAttribute(INamedTypeSymbol symbol)
        => symbol.GetAttributes().Any(attr => IsNamed(attr, generateAttributeNames));

    private static AttributeData? GetFirstMatchingAttribute(ISymbol symbol, IReadOnlyList<string> names)
        => symbol.GetAttributes().FirstOrDefault(attr => IsNamed(attr, names));

    private static bool IsNamed(AttributeData attribute, IReadOnlyList<string> names)
    {
        var name = attribute.AttributeClass?.ToDisplayString();
        if (name is null)
            return false;

        foreach (var candidate in names)
        {
            if (string.Equals(name, candidate, StringComparison.Ordinal))
                return true;
        }

        return false;
    }

    private sealed record TypeDescriptor(string FullyQualifiedName, IReadOnlyList<MemberDescriptor> Members);

    private sealed record MemberDescriptor(
        string MemberName,
        string HeaderName,
        int? AttributeIndex,
        string TypeName,
        string ConverterFactory,
        string SetterFactory);

    private sealed record ConverterDescriptor(string Factory);

    private sealed class SourceBuilder
    {
        private readonly System.Text.StringBuilder builder = new();
        private int indent;
        private const string INDENT_STRING = "    ";

        public void Indent() => indent++;
        public void Unindent() => indent = Math.Max(0, indent - 1);

        public void AppendLine(string line = "")
        {
            for (int i = 0; i < indent; i++)
                builder.Append(INDENT_STRING);
            builder.AppendLine(line);
        }

        public override string ToString() => builder.ToString();
    }
}
