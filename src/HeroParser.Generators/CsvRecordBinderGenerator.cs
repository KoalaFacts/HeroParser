using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using static HeroParser.Generators.GeneratorHelpers;

namespace HeroParser.Generators;

/// <summary>
/// Source generator for CSV record binders.
/// Generates both legacy boxing-based binders and high-performance typed binders.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class CsvRecordBinderGenerator : IIncrementalGenerator
{
    private const string GENERATED_NAMESPACE = "HeroParser.SeparatedValues.Records.Binding";
    private const string BINDER_TYPE = "global::HeroParser.CsvRecordBinder";
    private const string BINDER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Records.Binding.CsvRecordBinderFactory";
    private const string TYPED_BINDER_INTERFACE = "global::HeroParser.SeparatedValues.Records.Binding.ICsvTypedBinder";
    private const string WRITER_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriter";
    private const string WRITER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriterFactory";
    private const string ROW_TYPE = "global::HeroParser.SeparatedValues.CsvCharSpanRow";
    private const string EXCEPTION_TYPE = "global::HeroParser.SeparatedValues.CsvException";
    private const string ERROR_CODE_TYPE = "global::HeroParser.SeparatedValues.CsvErrorCode";

    private static readonly string[] generateAttributeNames =
    [
        "HeroParser.SeparatedValues.Records.Binding.CsvGenerateBinderAttribute",
        "HeroParser.CsvGenerateBinderAttribute"
    ];

    private static readonly string[] columnAttributeNames =
    [
        "HeroParser.SeparatedValues.Records.Binding.CsvColumnAttribute",
        "HeroParser.CsvColumnAttribute"
    ];

#pragma warning disable RS2008 // Enable analyzer release tracking - not needed for internal generator
    private static readonly DiagnosticDescriptor unsupportedPropertyTypeDiagnostic = new(
        "HERO001",
        "Unsupported property type",
        "Property '{0}' of type '{1}' is not supported by the CSV record binder generator. Supported types include primitives, DateTime, DateTimeOffset, DateOnly, TimeOnly, Guid, TimeZoneInfo, and enums.",
        "HeroParser.Generators",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);
#pragma warning restore RS2008

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Use ForAttributeWithMetadataName for better caching - register for both attribute names
        var provider1 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[0],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        var provider2 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[1],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        // Combine both providers
        var combined = provider1.Collect().Combine(provider2.Collect());

        // Generate per-type typed binder files for better incrementality
        context.RegisterSourceOutput(provider1, static (spc, descriptor) => EmitTypedBinder(spc, descriptor!));
        context.RegisterSourceOutput(provider2, static (spc, descriptor) => EmitTypedBinder(spc, descriptor!));

        // Generate registration file
        context.RegisterSourceOutput(combined, static (spc, tuple) =>
        {
            var all = tuple.Left.Concat(tuple.Right).Where(x => x is not null).ToList();
            if (all.Count > 0)
                EmitRegistration(spc, all!);
        });
    }

    private static TypeDescriptor? TransformToDescriptor(GeneratorAttributeSyntaxContext ctx, CancellationToken ct)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;

        if (symbol.IsAbstract || !IsTypeAccessible(symbol))
            return null;

        return BuildDescriptor(symbol, ct);
    }

    private static void EmitTypedBinder(SourceProductionContext context, TypeDescriptor descriptor)
    {
        // Report diagnostics
        foreach (var diag in descriptor.Diagnostics)
        {
            context.ReportDiagnostic(diag);
        }

        var binderMembers = GetMembersWithSetters(descriptor.Members);
        if (binderMembers.Count == 0)
            return;

        var builder = new SourceBuilder(16384);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Globalization;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();

        EmitTypedBinderClass(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName, binderMembers);

        context.AddSource($"CsvTypedBinder.{descriptor.SafeClassName}.g.cs", builder.ToString());
    }

    private static void EmitTypedBinderClass(SourceBuilder builder, string fullyQualifiedName, string safeClassName, IReadOnlyList<MemberDescriptor> members)
    {
        var binderClassName = $"CsvTypedBinder_{safeClassName}";

        builder.AppendLine($"internal sealed class {binderClassName} : {TYPED_BINDER_INTERFACE}<{fullyQualifiedName}>");
        builder.AppendLine("{");
        builder.Indent();

        // Fields for configuration
        builder.AppendLine("private readonly CultureInfo culture;");
        builder.AppendLine("private readonly StringComparison headerComparison;");
        builder.AppendLine("private readonly bool hasHeaderRow;");
        builder.AppendLine("private readonly bool allowMissingColumns;");
        builder.AppendLine("private readonly HashSet<string>? nullValues;");
        builder.AppendLine("private bool resolved;");
        builder.AppendLine();

        // Column index fields for each member
        foreach (var member in members)
        {
            builder.AppendLine($"private int columnIndex_{member.MemberName} = -1;");
        }
        builder.AppendLine();

        // Constructor
        builder.AppendLine($"public {binderClassName}(global::HeroParser.SeparatedValues.Records.CsvRecordOptions? options)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("options ??= global::HeroParser.SeparatedValues.Records.CsvRecordOptions.Default;");
        builder.AppendLine("this.culture = options.EffectiveCulture;");
        builder.AppendLine("this.headerComparison = options.CaseSensitiveHeaders ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;");
        builder.AppendLine("this.hasHeaderRow = options.HasHeaderRow;");
        builder.AppendLine("this.allowMissingColumns = options.AllowMissingColumns;");
        builder.AppendLine("this.nullValues = options.NullValues is { Count: > 0 } ? new HashSet<string>(options.NullValues, StringComparer.Ordinal) : null;");
        builder.AppendLine();

        // Initialize column indices from attribute indices or ordinal position
        builder.AppendLine("if (!hasHeaderRow)");
        builder.AppendLine("{");
        builder.Indent();
        int ordinal = 0;
        foreach (var member in members)
        {
            if (member.AttributeIndex.HasValue)
            {
                builder.AppendLine($"columnIndex_{member.MemberName} = {member.AttributeIndex.Value};");
            }
            else
            {
                builder.AppendLine($"columnIndex_{member.MemberName} = {ordinal};");
            }
            ordinal++;
        }
        builder.AppendLine("resolved = true;");
        builder.Unindent();
        builder.AppendLine("}");

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // NeedsHeaderResolution property
        builder.AppendLine("public bool NeedsHeaderResolution => hasHeaderRow && !resolved;");
        builder.AppendLine();

        // BindHeader method
        EmitBindHeaderMethod(builder, members);
        builder.AppendLine();

        // Bind method
        EmitBindMethod(builder, fullyQualifiedName);
        builder.AppendLine();

        // BindInto method
        EmitBindIntoMethod(builder, fullyQualifiedName, members);
        builder.AppendLine();

        // Helper methods
        EmitHelperMethods(builder);

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();
    }

    private static void EmitBindHeaderMethod(SourceBuilder builder, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"public void BindHeader({ROW_TYPE} headerRow, int rowNumber)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (!hasHeaderRow || resolved) return;");
        builder.AppendLine();

        foreach (var member in members)
        {
            if (member.AttributeIndex.HasValue)
            {
                builder.AppendLine($"columnIndex_{member.MemberName} = {member.AttributeIndex.Value};");
            }
            else
            {
                builder.AppendLine($"columnIndex_{member.MemberName} = FindHeaderIndex(headerRow, \"{member.HeaderName}\");");
                builder.AppendLine($"if (columnIndex_{member.MemberName} < 0 && !allowMissingColumns)");
                builder.AppendLine("{");
                builder.Indent();
                builder.AppendLine($"throw new {EXCEPTION_TYPE}({ERROR_CODE_TYPE}.ParseError, \"Column '{member.HeaderName}' not found in header.\", rowNumber);");
                builder.Unindent();
                builder.AppendLine("}");
            }
        }

        builder.AppendLine("resolved = true;");
        builder.Unindent();
        builder.AppendLine("}");
    }

    private static void EmitBindMethod(SourceBuilder builder, string fullyQualifiedName)
    {
        builder.AppendLine($"public {fullyQualifiedName}? Bind({ROW_TYPE} row, int rowNumber)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine($"var instance = new {fullyQualifiedName}();");
        builder.AppendLine("if (!BindInto(instance, row, rowNumber)) return null;");
        builder.AppendLine("return instance;");
        builder.Unindent();
        builder.AppendLine("}");
    }

    private static void EmitBindIntoMethod(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"public bool BindInto({fullyQualifiedName} instance, {ROW_TYPE} row, int rowNumber)");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            EmitMemberBinding(builder, member);
        }

        builder.AppendLine("return true;");
        builder.Unindent();
        builder.AppendLine("}");
    }

    private static void EmitMemberBinding(SourceBuilder builder, MemberDescriptor member)
    {
        var indexVar = $"columnIndex_{member.MemberName}";

        builder.AppendLine($"// {member.MemberName}");
        builder.AppendLine($"if ({indexVar} >= 0 && {indexVar} < row.ColumnCount)");
        builder.AppendLine("{");
        builder.Indent();

        builder.AppendLine($"var column_{member.MemberName} = row[{indexVar}];");
        builder.AppendLine($"var span_{member.MemberName} = column_{member.MemberName}.CharSpan;");

        // Check for null values
        builder.AppendLine($"if (!IsNullValue(span_{member.MemberName}))");
        builder.AppendLine("{");
        builder.Indent();

        EmitTypedParsing(builder, member, $"span_{member.MemberName}", $"column_{member.MemberName}");

        builder.Unindent();
        builder.AppendLine("}");

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine($"else if ({indexVar} >= 0 && !allowMissingColumns)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine($"throw new {EXCEPTION_TYPE}({ERROR_CODE_TYPE}.ParseError, $\"Row has only {{row.ColumnCount}} columns but '{member.MemberName}' expects index {{{indexVar}}}.\", rowNumber, {indexVar} + 1);");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();
    }

    private static void EmitTypedParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string columnVar)
    {
        var baseType = member.BaseTypeName;
        var isNullable = member.IsNullable;
        var propertyName = member.MemberName;

#pragma warning disable IDE0010 // Populate switch - intentionally not exhaustive
        switch (baseType)
        {
            case "string":
                builder.AppendLine($"instance.{propertyName} = new string({spanVar});");
                break;

            case "int":
            case "System.Int32":
                EmitNumericParsing(builder, member, spanVar, "int", "Integer");
                break;

            case "long":
            case "System.Int64":
                EmitNumericParsing(builder, member, spanVar, "long", "Integer");
                break;

            case "short":
            case "System.Int16":
                EmitNumericParsing(builder, member, spanVar, "short", "Integer");
                break;

            case "byte":
            case "System.Byte":
                EmitNumericParsing(builder, member, spanVar, "byte", "Integer");
                break;

            case "uint":
            case "System.UInt32":
                EmitNumericParsing(builder, member, spanVar, "uint", "Integer");
                break;

            case "ulong":
            case "System.UInt64":
                EmitNumericParsing(builder, member, spanVar, "ulong", "Integer");
                break;

            case "ushort":
            case "System.UInt16":
                EmitNumericParsing(builder, member, spanVar, "ushort", "Integer");
                break;

            case "sbyte":
            case "System.SByte":
                EmitNumericParsing(builder, member, spanVar, "sbyte", "Integer");
                break;

            case "decimal":
            case "System.Decimal":
                EmitNumericParsing(builder, member, spanVar, "decimal", "Number");
                break;

            case "double":
            case "System.Double":
                EmitFloatParsing(builder, member, spanVar, "double");
                break;

            case "float":
            case "System.Single":
                EmitFloatParsing(builder, member, spanVar, "float");
                break;

            case "bool":
            case "System.Boolean":
                EmitBooleanParsing(builder, member, spanVar);
                break;

            case "System.DateTime":
                EmitDateTimeParsing(builder, member, spanVar, "DateTime");
                break;

            case "System.DateTimeOffset":
                EmitDateTimeParsing(builder, member, spanVar, "DateTimeOffset");
                break;

            case "System.DateOnly":
                EmitDateTimeParsing(builder, member, spanVar, "DateOnly");
                break;

            case "System.TimeOnly":
                EmitDateTimeParsing(builder, member, spanVar, "TimeOnly");
                break;

            case "System.Guid":
                EmitGuidParsing(builder, member, spanVar);
                break;

            case "System.TimeZoneInfo":
                EmitTimeZoneInfoParsing(builder, member, columnVar);
                break;

            default:
                if (member.IsEnum)
                {
                    EmitEnumParsing(builder, member, spanVar, isNullable);
                }
                else
                {
                    builder.AppendLine($"instance.{propertyName} = new string({spanVar});");
                }
                break;
        }
#pragma warning restore IDE0010
    }

    private static void EmitNumericParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string typeName, string numberStyle)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        var styles = numberStyle == "Integer" ? "NumberStyles.Integer" : "NumberStyles.Number";

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty) {{ /* null */ }}");
            builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
        else
        {
            builder.AppendLine($"if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
    }

    private static void EmitFloatParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string typeName)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        const string STYLES = "NumberStyles.Float | NumberStyles.AllowThousands";

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty) {{ /* null */ }}");
            builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, {STYLES}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
        else
        {
            builder.AppendLine($"if ({typeName}.TryParse({spanVar}, {STYLES}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
    }

    private static void EmitBooleanParsing(SourceBuilder builder, MemberDescriptor member, string spanVar)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty) {{ /* null */ }}");
            builder.AppendLine($"else if (bool.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
        else
        {
            builder.AppendLine($"if (bool.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
    }

    private static void EmitDateTimeParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string typeName)
    {
        var propertyName = member.MemberName;
        var format = member.Format;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty) {{ /* null */ }}");
            if (format != null)
            {
                builder.AppendLine($"else if ({typeName}.TryParseExact({spanVar}, \"{EscapeString(format)}\", culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            else
            {
                builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
        else
        {
            if (format != null)
            {
                builder.AppendLine($"if ({typeName}.TryParseExact({spanVar}, \"{EscapeString(format)}\", culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            else
            {
                builder.AppendLine($"if ({typeName}.TryParse({spanVar}, culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
    }

    private static void EmitGuidParsing(SourceBuilder builder, MemberDescriptor member, string spanVar)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty) {{ /* null */ }}");
            builder.AppendLine($"else if (Guid.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
        else
        {
            builder.AppendLine($"if (Guid.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
    }

    private static void EmitTimeZoneInfoParsing(SourceBuilder builder, MemberDescriptor member, string columnVar)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({columnVar}.IsEmpty) {{ /* null */ }}");
            builder.AppendLine($"else if ({columnVar}.TryParseTimeZoneInfo(out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
        else
        {
            builder.AppendLine($"if ({columnVar}.TryParseTimeZoneInfo(out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
    }

    private static void EmitEnumParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, bool isNullable)
    {
        var propertyName = member.MemberName;
        var enumType = member.TypeofTypeName;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty) {{ /* null */ }}");
            builder.AppendLine($"else if (Enum.TryParse<{enumType}>({spanVar}, ignoreCase: true, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
        else
        {
            builder.AppendLine($"if (Enum.TryParse<{enumType}>({spanVar}, ignoreCase: true, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
        }
    }

    private static void EmitHelperMethods(SourceBuilder builder)
    {
        // FindHeaderIndex helper
        builder.AppendLine($"private int FindHeaderIndex({ROW_TYPE} headerRow, string headerName)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("var target = headerName.AsSpan();");
        builder.AppendLine("for (int i = 0; i < headerRow.ColumnCount; i++)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("var candidate = headerRow[i].CharSpan;");
        builder.AppendLine("if (headerComparison == StringComparison.Ordinal)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (candidate.SequenceEqual(target)) return i;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine("else if (candidate.Equals(target, headerComparison))");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("return i;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine("return -1;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // IsNullValue helper
        builder.AppendLine("private bool IsNullValue(ReadOnlySpan<char> span)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (nullValues is null) return false;");
        builder.AppendLine("foreach (var nv in nullValues)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (span.SequenceEqual(nv.AsSpan())) return true;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine("return false;");
        builder.Unindent();
        builder.AppendLine("}");
    }

    private static void EmitRegistration(SourceProductionContext context, IReadOnlyList<TypeDescriptor> descriptors)
    {
        var builder = new SourceBuilder(8192);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();
        builder.AppendLine("file static class CsvRecordBinderGeneratedRegistration");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("[ModuleInitializer]");
        builder.AppendLine("internal static void Register()");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var descriptor in descriptors)
        {
            // Filter members for binder (those with setters)
            var binderMembers = GetMembersWithSetters(descriptor.Members);
            if (binderMembers.Count > 0)
            {
                // Register legacy binder for backwards compatibility
                EmitLegacyBinderRegistration(builder, descriptor.FullyQualifiedName, binderMembers);

                // Register typed binder for performance
                EmitTypedBinderRegistration(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName);
            }

            // Filter members for writer (those with getters)
            var writerMembers = GetMembersWithGetters(descriptor.Members);
            if (writerMembers.Count > 0)
            {
                EmitWriterRegistration(builder, descriptor.FullyQualifiedName, writerMembers);
            }
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("CsvRecordBinderFactory.Registration.g.cs", builder.ToString());
    }

    private static void EmitTypedBinderRegistration(SourceBuilder builder, string fullyQualifiedName, string safeClassName)
    {
        var binderClassName = $"CsvTypedBinder_{safeClassName}";
        builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterTypedBinder<{fullyQualifiedName}>(options => new {binderClassName}(options));");
    }

    private static void EmitLegacyBinderRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterGeneratedBinder(typeof({fullyQualifiedName}), options => {BINDER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {BINDER_TYPE}<{fullyQualifiedName}>.BindingTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {BINDER_TYPE}<{fullyQualifiedName}>.BindingTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeName}),");
            builder.AppendLine($"\"{member.HeaderName}\",");
            builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.SetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static List<MemberDescriptor> GetMembersWithSetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.SetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static List<MemberDescriptor> GetMembersWithGetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.GetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static void EmitWriterRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{WRITER_FACTORY_TYPE}.RegisterGeneratedWriter(typeof({fullyQualifiedName}), options => {WRITER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeName}),");
            builder.AppendLine($"\"{member.HeaderName}\",");
            builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.GetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static TypeDescriptor? BuildDescriptor(INamedTypeSymbol type, CancellationToken ct)
    {
        var members = new List<MemberDescriptor>();
        var diagnostics = new List<Diagnostic>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            ct.ThrowIfCancellationRequested();

            if (property.IsStatic)
                continue;

            var hasSetter = property.SetMethod is { DeclaredAccessibility: Accessibility.Public };
            var hasGetter = property.GetMethod is { DeclaredAccessibility: Accessibility.Public };

            if (!hasSetter && !hasGetter)
                continue;

            var mapAttribute = GetFirstMatchingAttribute(property, columnAttributeNames);
            var headerName = property.Name;
            int? attributeIndex = null;
            string? format = null;

            if (mapAttribute is not null)
            {
#pragma warning disable IDE0010 // Populate switch - intentionally not exhaustive
                foreach (var arg in mapAttribute.NamedArguments)
                {
                    switch (arg.Key)
                    {
                        case "Name" when arg.Value.Value is string s && !string.IsNullOrWhiteSpace(s):
                            headerName = s;
                            break;
                        case "Index" when arg.Value.Value is int i && i >= 0:
                            attributeIndex = i;
                            break;
                        case "Format" when arg.Value.Value is string f && !string.IsNullOrWhiteSpace(f):
                            format = f;
                            break;
                    }
                }
#pragma warning restore IDE0010
            }

            if (!IsSupportedType(property.Type))
            {
                diagnostics.Add(Diagnostic.Create(
                    unsupportedPropertyTypeDiagnostic,
                    property.Locations.FirstOrDefault() ?? Location.None,
                    property.Name,
                    property.Type.ToDisplayString()));
                continue;
            }

            var typeName = property.Type.ToDisplayString(FullyQualifiedFormatWithNullable);
            var typeofTypeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var headerLiteral = EscapeString(headerName);
            var formatLiteral = format != null ? EscapeString(format) : null;

            var (baseTypeName, isNullable, isEnum) = GetBaseTypeInfo(property.Type);

            var setterFactory = hasSetter ? CreateSetter(typeName, type, property.Name) : null;
            var getterFactory = hasGetter ? CreateGetter(type, property.Name) : null;

            members.Add(new MemberDescriptor(
                property.Name,
                headerLiteral,
                attributeIndex,
                typeName,
                typeofTypeName,
                formatLiteral,
                setterFactory,
                getterFactory,
                baseTypeName,
                isNullable,
                isEnum));
        }

        if (members.Count == 0 && diagnostics.Count == 0)
            return null;

        var fqName = type.ToDisplayString(FullyQualifiedFormatWithNullable);
        var safeClassName = CreateSafeClassName(type);
        return new TypeDescriptor(fqName, safeClassName, members, diagnostics);
    }

    private static (string baseTypeName, bool isNullable, bool isEnum) GetBaseTypeInfo(ITypeSymbol type)
    {
        var isNullable = false;
        var actualType = type;

        if (type is INamedTypeSymbol { IsGenericType: true, Name: "Nullable" } nullable)
        {
            isNullable = true;
            actualType = nullable.TypeArguments[0];
        }

        if (type.NullableAnnotation == NullableAnnotation.Annotated && type.OriginalDefinition.SpecialType == SpecialType.None)
        {
            isNullable = true;
        }

        var isEnum = actualType.TypeKind == TypeKind.Enum;
        var baseTypeName = actualType.ToDisplayString();

        return (baseTypeName, isNullable, isEnum);
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private static string CreateGetter(INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target) => target.{propertyName}";

    private sealed record TypeDescriptor(
        string FullyQualifiedName,
        string SafeClassName,
        IReadOnlyList<MemberDescriptor> Members,
        IReadOnlyList<Diagnostic> Diagnostics);

    private sealed record MemberDescriptor(
        string MemberName,
        string HeaderName,
        int? AttributeIndex,
        string TypeName,
        string TypeofTypeName,
        string? Format,
        string? SetterFactory,
        string? GetterFactory,
        string BaseTypeName,
        bool IsNullable,
        bool IsEnum);
}
