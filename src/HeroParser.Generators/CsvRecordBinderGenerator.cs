using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace HeroParser.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class CsvRecordBinderGenerator : IIncrementalGenerator
{
    private const string GENERATED_NAMESPACE = "HeroParser.SeparatedValues.Records.Binding";
    private const string BINDER_TYPE = "global::HeroParser.CsvRecordBinder";
    private const string BINDER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Records.Binding.CsvRecordBinderFactory";
    private const string WRITER_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriter";
    private const string WRITER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriterFactory";
    private static readonly string[] generateAttributeNames = ["HeroParser.SeparatedValues.Records.Binding.CsvGenerateBinderAttribute", "HeroParser.CsvGenerateBinderAttribute"];

    private static readonly string[] columnAttributeNames = ["HeroParser.SeparatedValues.Records.Binding.CsvColumnAttribute", "HeroParser.CsvColumnAttribute"];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (ctx, _) =>
                {
                    if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) is not INamedTypeSymbol symbol)
                        return null;

                    return HasGenerateAttribute(symbol) ? symbol : null;
                })
            .Where(x => x is not null)
            .Select((symbol, _) => symbol!)!;

        var collected = candidates.Collect();

        context.RegisterSourceOutput(collected, static (spc, symbols) => Emit(spc, symbols!));
    }

    private static void Emit(SourceProductionContext context, IReadOnlyList<INamedTypeSymbol> symbols)
    {
        if (symbols.Count == 0)
            return;

        var builder = new SourceBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();
        builder.AppendLine("file static class CsvRecordBinderGeneratedRegistration");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("[ModuleInitializer]");
        builder.AppendLine("internal static void Register()");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var symbol in symbols)
        {
            if (symbol is null || symbol.IsAbstract)
                continue;

            var descriptor = BuildDescriptor(context, symbol);
            if (descriptor is null)
                continue;

            // Filter members for binder (those with setters)
            var binderMembers = descriptor.Members.Where(m => m.SetterFactory != null).ToList();
            if (binderMembers.Count > 0)
            {
                EmitBinderRegistration(builder, descriptor.FullyQualifiedName, binderMembers);
            }

            // Filter members for writer (those with getters)
            var writerMembers = descriptor.Members.Where(m => m.GetterFactory != null).ToList();
            if (writerMembers.Count > 0)
            {
                EmitWriterRegistration(builder, descriptor.FullyQualifiedName, writerMembers);
            }
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("CsvRecordBinderFactory.g.cs", builder.ToString());
    }

    private static void EmitBinderRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterGeneratedBinder(typeof({fullyQualifiedName}), options => {BINDER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {BINDER_TYPE}<{fullyQualifiedName}>.BindingTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {BINDER_TYPE}<{fullyQualifiedName}>.BindingTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeName}),");
            builder.AppendLine($"\"{member.HeaderName}\",");
            builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.SetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static void EmitWriterRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{WRITER_FACTORY_TYPE}.RegisterGeneratedWriter(typeof({fullyQualifiedName}), options => {WRITER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeName}),");
            builder.AppendLine($"\"{member.HeaderName}\",");
            builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.GetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static TypeDescriptor? BuildDescriptor(SourceProductionContext context, INamedTypeSymbol type)
    {
        // Skip types that are not publicly accessible (private, internal nested, etc.)
        if (!IsTypeAccessible(type))
            return null;

        var members = new List<MemberDescriptor>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (property.IsStatic)
                continue;

            // Check accessibility - need at least one of getter/setter to be public
            var hasSetter = property.SetMethod is { DeclaredAccessibility: Accessibility.Public };
            var hasGetter = property.GetMethod is { DeclaredAccessibility: Accessibility.Public };

            if (!hasSetter && !hasGetter)
                continue;

            var mapAttribute = GetFirstMatchingAttribute(property, columnAttributeNames);
            var headerName = property.Name;
            int? attributeIndex = null;
            string? format = null;
            if (mapAttribute is not null)
            {
                foreach (var arg in mapAttribute.NamedArguments)
                {
                    if (arg.Key == "Name" && arg.Value.Value is string s && !string.IsNullOrWhiteSpace(s))
                        headerName = s;
                    if (arg.Key == "Index" && arg.Value.Value is int i && i >= 0)
                        attributeIndex = i;
                    if (arg.Key == "Format" && arg.Value.Value is string f && !string.IsNullOrWhiteSpace(f))
                        format = f;
                }
            }

            // Check if type is supported (for diagnostic reporting)
            if (!IsSupportedType(property.Type))
            {
                // Report diagnostic for unsupported property type
                var diagnostic = Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "HERO001",
                        "Unsupported property type",
                        "Property '{0}' of type '{1}' is not supported by the CSV record binder generator. Supported types include primitives, DateTime, DateTimeOffset, DateOnly, TimeOnly, Guid, TimeZoneInfo, and enums.",
                        "HeroParser.Generators",
                        DiagnosticSeverity.Warning,
                        isEnabledByDefault: true),
                    property.Locations.FirstOrDefault() ?? Location.None,
                    property.Name,
                    property.Type.ToDisplayString());
                context.ReportDiagnostic(diagnostic);
                continue; // Skip this property but continue with others
            }

            var typeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            var headerLiteral = EscapeString(headerName);
            var formatLiteral = format != null ? EscapeString(format) : null;

            // Generate setter only if property has public setter (for binder/reader)
            string? setterFactory = hasSetter ? CreateSetter(typeName, type, property.Name) : null;

            // Generate getter only if property has public getter (for writer)
            string? getterFactory = hasGetter ? CreateGetter(type, property.Name) : null;

            members.Add(new MemberDescriptor(
                property.Name,
                headerLiteral,
                attributeIndex,
                typeName,
                formatLiteral,
                setterFactory,
                getterFactory));
        }

        if (members.Count == 0)
            return null;

        var fqName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        return new TypeDescriptor(fqName, members);
    }

    private static bool IsSupportedType(ITypeSymbol type)
    {
        var underlying = type is INamedTypeSymbol named && named.IsGenericType && named.Name == "Nullable"
            ? named.TypeArguments[0]
            : type;

        return underlying.SpecialType switch
        {
            SpecialType.System_String => true,
            SpecialType.System_Int32 => true,
            SpecialType.System_Int64 => true,
            SpecialType.System_Int16 => true,
            SpecialType.System_Byte => true,
            SpecialType.System_UInt32 => true,
            SpecialType.System_UInt64 => true,
            SpecialType.System_UInt16 => true,
            SpecialType.System_SByte => true,
            SpecialType.System_Double => true,
            SpecialType.System_Single => true,
            SpecialType.System_Decimal => true,
            SpecialType.System_Boolean => true,
            _ => IsSupportedComplexType(underlying)
        };
    }

    private static bool IsSupportedComplexType(ITypeSymbol type)
    {
        return type.ToDisplayString() switch
        {
            "System.DateTime" => true,
            "System.DateTimeOffset" => true,
            "System.DateOnly" => true,
            "System.TimeOnly" => true,
            "System.Guid" => true,
            "System.TimeZoneInfo" => true,
            _ when type.TypeKind == TypeKind.Enum => true,
            _ => false
        };
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private static string CreateGetter(INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target) => target.{propertyName}";

    private static string EscapeString(string value)
    {
        // Escape backslashes and quotes for C# string literals
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static bool HasGenerateAttribute(INamedTypeSymbol symbol)
        => symbol.GetAttributes().Any(attr => IsNamed(attr, generateAttributeNames));

    private static AttributeData? GetFirstMatchingAttribute(ISymbol symbol, IReadOnlyList<string> names)
        => symbol.GetAttributes().FirstOrDefault(attr => IsNamed(attr, names));

    private static bool IsNamed(AttributeData attribute, IReadOnlyList<string> names)
    {
        var name = attribute.AttributeClass?.ToDisplayString();
        if (name is null)
            return false;

        foreach (var candidate in names)
        {
            if (string.Equals(name, candidate, StringComparison.Ordinal))
                return true;
        }

        return false;
    }

    private static bool IsTypeAccessible(INamedTypeSymbol type)
    {
        // Check if the type itself and all containing types are at least internal
        var current = type;
        while (current is not null)
        {
            if (current.DeclaredAccessibility == Accessibility.Private ||
                current.DeclaredAccessibility == Accessibility.Protected ||
                current.DeclaredAccessibility == Accessibility.ProtectedAndInternal)
            {
                return false;
            }
            current = current.ContainingType;
        }
        return true;
    }

    private sealed record TypeDescriptor(string FullyQualifiedName, IReadOnlyList<MemberDescriptor> Members);

    private sealed record MemberDescriptor(
        string MemberName,
        string HeaderName,
        int? AttributeIndex,
        string TypeName,
        string? Format,
        string? SetterFactory,
        string? GetterFactory);

    private sealed class SourceBuilder
    {
        private readonly System.Text.StringBuilder builder = new();
        private int indent;
        private const string INDENT_STRING = "    ";

        public void Indent() => indent++;
        public void Unindent() => indent = Math.Max(0, indent - 1);

        public void AppendLine(string line = "")
        {
            for (int i = 0; i < indent; i++)
                builder.Append(INDENT_STRING);
            builder.AppendLine(line);
        }

        public override string ToString() => builder.ToString();
    }
}
