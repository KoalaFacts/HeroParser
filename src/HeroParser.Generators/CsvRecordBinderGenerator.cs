using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using static HeroParser.Generators.GeneratorHelpers;

namespace HeroParser.Generators;

/// <summary>
/// Source generator for CSV record descriptors.
/// Generates property descriptors for high-performance binding via CsvDescriptorBinder{T}.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class CsvRecordBinderGenerator : IIncrementalGenerator
{
    private const string GENERATED_NAMESPACE = "HeroParser.SeparatedValues.Records.Binding";
    private const string BINDER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Records.Binding.CsvRecordBinderFactory";
    private const string WRITER_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriter";
    private const string WRITER_FACTORY_TYPE = "global::HeroParser.SeparatedValues.Writing.CsvRecordWriterFactory";
    private const string DESCRIPTOR_TYPE = "global::HeroParser.SeparatedValues.Records.Binding.CsvRecordDescriptor";
    private const string PROPERTY_DESCRIPTOR_TYPE = "global::HeroParser.SeparatedValues.Records.Binding.CsvPropertyDescriptor";

    private static readonly string[] generateAttributeNames =
    [
        "HeroParser.SeparatedValues.Records.Binding.CsvGenerateBinderAttribute",
        "HeroParser.CsvGenerateBinderAttribute"
    ];

    private static readonly string[] columnAttributeNames =
    [
        "HeroParser.SeparatedValues.Records.Binding.CsvColumnAttribute",
        "HeroParser.CsvColumnAttribute"
    ];

#pragma warning disable RS2008 // Enable analyzer release tracking - not needed for internal generator
    private static readonly DiagnosticDescriptor unsupportedPropertyTypeDiagnostic = new(
        "HERO001",
        "Unsupported property type",
        "Property '{0}' of type '{1}' is not supported by the CSV record binder generator. Supported types include primitives, DateTime, DateTimeOffset, DateOnly, TimeOnly, Guid, TimeZoneInfo, and enums.",
        "HeroParser.Generators",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);
#pragma warning restore RS2008

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Use ForAttributeWithMetadataName for better caching - register for both attribute names
        var provider1 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[0],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        var provider2 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[1],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        // Combine both providers
        var combined = provider1.Collect().Combine(provider2.Collect());

        // Generate per-type typed binder files for better incrementality
        context.RegisterSourceOutput(provider1, static (spc, descriptor) => EmitTypedBinder(spc, descriptor!));
        context.RegisterSourceOutput(provider2, static (spc, descriptor) => EmitTypedBinder(spc, descriptor!));

        // Generate registration file
        context.RegisterSourceOutput(combined, static (spc, tuple) =>
        {
            var all = tuple.Left.Concat(tuple.Right).Where(x => x is not null).ToList();
            if (all.Count > 0)
                EmitRegistration(spc, all!);
        });
    }

    private static TypeDescriptor? TransformToDescriptor(GeneratorAttributeSyntaxContext ctx, CancellationToken ct)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;

        if (symbol.IsAbstract || !IsTypeAccessible(symbol))
            return null;

        return BuildDescriptor(symbol, ct);
    }

    private static void EmitTypedBinder(SourceProductionContext context, TypeDescriptor descriptor)
    {
        // Report diagnostics
        foreach (var diag in descriptor.Diagnostics)
        {
            context.ReportDiagnostic(diag);
        }

        var binderMembers = GetMembersWithSetters(descriptor.Members);
        if (binderMembers.Count == 0)
            return;

        var builder = new SourceBuilder(16384);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Globalization;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();

        // Emit descriptor class for optimized binding
        EmitDescriptorClass(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName, binderMembers);

        context.AddSource($"CsvTypedBinder.{descriptor.SafeClassName}.g.cs", builder.ToString());
    }

    private static void EmitDescriptorClass(SourceBuilder builder, string fullyQualifiedName, string safeClassName, IReadOnlyList<MemberDescriptor> members)
    {
        var descriptorClassName = $"CsvDescriptor_{safeClassName}";

        builder.AppendLine($"internal static class {descriptorClassName}");
        builder.AppendLine("{");
        builder.Indent();

        // Emit static setter methods for each property
        foreach (var member in members)
        {
            EmitPropertySetterMethod(builder, fullyQualifiedName, member);
        }
        builder.AppendLine();

        // Emit static descriptor instance using lazy initialization for thread safety
        builder.AppendLine($"private static {DESCRIPTOR_TYPE}<{fullyQualifiedName}>? _instance;");
        builder.AppendLine();

        // Emit GetDescriptor method that returns the cached descriptor
        builder.AppendLine($"public static {DESCRIPTOR_TYPE}<{fullyQualifiedName}> GetDescriptor()");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("return _instance ??= CreateDescriptor();");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // Emit CreateDescriptor method that builds the descriptor
        builder.AppendLine($"private static {DESCRIPTOR_TYPE}<{fullyQualifiedName}> CreateDescriptor()");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine($"var properties = new {PROPERTY_DESCRIPTOR_TYPE}<{fullyQualifiedName}>[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            var isRequired = !member.IsNullable && member.BaseTypeName != "string";
            var indexValue = member.AttributeIndex.HasValue ? member.AttributeIndex.Value.ToString() : "-1";
            builder.AppendLine($"new {PROPERTY_DESCRIPTOR_TYPE}<{fullyQualifiedName}>(\"{member.HeaderName}\", {indexValue}, Set_{member.MemberName}, {(isRequired ? "true" : "false")}),");
        }

        builder.Unindent();
        builder.AppendLine("};");
        builder.AppendLine($"return new {DESCRIPTOR_TYPE}<{fullyQualifiedName}>(properties);");
        builder.Unindent();
        builder.AppendLine("}");

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();
    }

    private static void EmitPropertySetterMethod(SourceBuilder builder, string fullyQualifiedName, MemberDescriptor member)
    {
        builder.AppendLine($"private static void Set_{member.MemberName}({fullyQualifiedName} instance, ReadOnlySpan<char> span, CultureInfo culture)");
        builder.AppendLine("{");
        builder.Indent();

        // Emit parsing logic based on type
        EmitSetterParsingLogic(builder, member);

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();
    }

    private static void EmitSetterParsingLogic(SourceBuilder builder, MemberDescriptor member)
    {
        var baseType = member.BaseTypeName;

#pragma warning disable IDE0010 // Populate switch - intentionally not exhaustive
        switch (baseType)
        {
            case "string":
                builder.AppendLine($"instance.{member.MemberName} = new string(span);");
                break;

            case "int":
            case "System.Int32":
                EmitSetterNumericParsing(builder, member, "int", "Integer");
                break;

            case "long":
            case "System.Int64":
                EmitSetterNumericParsing(builder, member, "long", "Integer");
                break;

            case "short":
            case "System.Int16":
                EmitSetterNumericParsing(builder, member, "short", "Integer");
                break;

            case "byte":
            case "System.Byte":
                EmitSetterNumericParsing(builder, member, "byte", "Integer");
                break;

            case "uint":
            case "System.UInt32":
                EmitSetterNumericParsing(builder, member, "uint", "Integer");
                break;

            case "ulong":
            case "System.UInt64":
                EmitSetterNumericParsing(builder, member, "ulong", "Integer");
                break;

            case "ushort":
            case "System.UInt16":
                EmitSetterNumericParsing(builder, member, "ushort", "Integer");
                break;

            case "sbyte":
            case "System.SByte":
                EmitSetterNumericParsing(builder, member, "sbyte", "Integer");
                break;

            case "decimal":
            case "System.Decimal":
                EmitSetterNumericParsing(builder, member, "decimal", "Number");
                break;

            case "double":
            case "System.Double":
                EmitSetterFloatParsing(builder, member, "double");
                break;

            case "float":
            case "System.Single":
                EmitSetterFloatParsing(builder, member, "float");
                break;

            case "bool":
            case "System.Boolean":
                EmitSetterBooleanParsing(builder, member);
                break;

            case "System.DateTime":
                EmitSetterDateTimeParsing(builder, member, "DateTime");
                break;

            case "System.DateTimeOffset":
                EmitSetterDateTimeParsing(builder, member, "DateTimeOffset");
                break;

            case "System.DateOnly":
                EmitSetterDateTimeParsing(builder, member, "DateOnly");
                break;

            case "System.TimeOnly":
                EmitSetterDateTimeParsing(builder, member, "TimeOnly");
                break;

            case "System.Guid":
                EmitSetterGuidParsing(builder, member);
                break;

            default:
                if (member.IsEnum)
                {
                    EmitSetterEnumParsing(builder, member);
                }
                else
                {
                    builder.AppendLine($"instance.{member.MemberName} = new string(span);");
                }
                break;
        }
#pragma warning restore IDE0010
    }

    private static void EmitSetterNumericParsing(SourceBuilder builder, MemberDescriptor member, string typeName, string numberStyle)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        var styles = numberStyle == "Integer" ? "NumberStyles.Integer" : "NumberStyles.Number";

        if (isNullable)
        {
            builder.AppendLine($"if (!span.IsEmpty && {typeName}.TryParse(span, {styles}, culture, out var parsed))");
            builder.AppendLine($"    instance.{propertyName} = parsed;");
        }
        else
        {
            builder.AppendLine($"instance.{propertyName} = {typeName}.Parse(span, {styles}, culture);");
        }
    }

    private static void EmitSetterFloatParsing(SourceBuilder builder, MemberDescriptor member, string typeName)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        const string STYLES = "NumberStyles.Float | NumberStyles.AllowThousands";

        if (isNullable)
        {
            builder.AppendLine($"if (!span.IsEmpty && {typeName}.TryParse(span, {STYLES}, culture, out var parsed))");
            builder.AppendLine($"    instance.{propertyName} = parsed;");
        }
        else
        {
            builder.AppendLine($"instance.{propertyName} = {typeName}.Parse(span, {STYLES}, culture);");
        }
    }

    private static void EmitSetterBooleanParsing(SourceBuilder builder, MemberDescriptor member)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if (!span.IsEmpty && bool.TryParse(span, out var parsed))");
            builder.AppendLine($"    instance.{propertyName} = parsed;");
        }
        else
        {
            builder.AppendLine($"instance.{propertyName} = bool.Parse(span);");
        }
    }

    private static void EmitSetterDateTimeParsing(SourceBuilder builder, MemberDescriptor member, string typeName)
    {
        var propertyName = member.MemberName;
        var format = member.Format;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if (!span.IsEmpty)");
            builder.AppendLine("{");
            builder.Indent();
            if (format != null)
            {
                builder.AppendLine($"if ({typeName}.TryParseExact(span, \"{EscapeString(format)}\", culture, DateTimeStyles.None, out var parsed))");
            }
            else
            {
                builder.AppendLine($"if ({typeName}.TryParse(span, culture, DateTimeStyles.None, out var parsed))");
            }
            builder.AppendLine($"    instance.{propertyName} = parsed;");
            builder.Unindent();
            builder.AppendLine("}");
        }
        else
        {
            if (format != null)
            {
                builder.AppendLine($"instance.{propertyName} = {typeName}.ParseExact(span, \"{EscapeString(format)}\", culture, DateTimeStyles.None);");
            }
            else
            {
                builder.AppendLine($"instance.{propertyName} = {typeName}.Parse(span, culture, DateTimeStyles.None);");
            }
        }
    }

    private static void EmitSetterGuidParsing(SourceBuilder builder, MemberDescriptor member)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if (!span.IsEmpty && Guid.TryParse(span, out var parsed))");
            builder.AppendLine($"    instance.{propertyName} = parsed;");
        }
        else
        {
            builder.AppendLine($"instance.{propertyName} = Guid.Parse(span);");
        }
    }

    private static void EmitSetterEnumParsing(SourceBuilder builder, MemberDescriptor member)
    {
        var propertyName = member.MemberName;
        var enumType = member.TypeofTypeName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if (!span.IsEmpty && Enum.TryParse<{enumType}>(span, ignoreCase: true, out var parsed))");
            builder.AppendLine($"    instance.{propertyName} = parsed;");
        }
        else
        {
            builder.AppendLine($"instance.{propertyName} = Enum.Parse<{enumType}>(span, ignoreCase: true);");
        }
    }

    private static void EmitRegistration(SourceProductionContext context, IReadOnlyList<TypeDescriptor> descriptors)
    {
        var builder = new SourceBuilder(8192);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();
        builder.AppendLine("file static class CsvRecordBinderGeneratedRegistration");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("[ModuleInitializer]");
        builder.AppendLine("internal static void Register()");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var descriptor in descriptors)
        {
            // Filter members for binder (those with setters)
            var binderMembers = GetMembersWithSetters(descriptor.Members);
            if (binderMembers.Count > 0)
            {
                // Register descriptor-based binder for performance
                EmitTypedBinderRegistration(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName);
            }

            // Filter members for writer (those with getters)
            var writerMembers = GetMembersWithGetters(descriptor.Members);
            if (writerMembers.Count > 0)
            {
                EmitWriterRegistration(builder, descriptor.FullyQualifiedName, writerMembers);
            }
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("CsvRecordBinderFactory.Registration.g.cs", builder.ToString());
    }

    private static void EmitTypedBinderRegistration(SourceBuilder builder, string fullyQualifiedName, string safeClassName)
    {
        var descriptorClassName = $"CsvDescriptor_{safeClassName}";
        builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterDescriptor<{fullyQualifiedName}>({descriptorClassName}.GetDescriptor);");
    }

    private static List<MemberDescriptor> GetMembersWithSetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.SetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static List<MemberDescriptor> GetMembersWithGetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.GetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static void EmitWriterRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{WRITER_FACTORY_TYPE}.RegisterGeneratedWriter(typeof({fullyQualifiedName}), options => {WRITER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeofTypeName}),");
            builder.AppendLine($"\"{member.HeaderName}\",");
            builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.GetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static TypeDescriptor? BuildDescriptor(INamedTypeSymbol type, CancellationToken ct)
    {
        var members = new List<MemberDescriptor>();
        var diagnostics = new List<Diagnostic>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            ct.ThrowIfCancellationRequested();

            if (property.IsStatic)
                continue;

            var hasSetter = property.SetMethod is { DeclaredAccessibility: Accessibility.Public };
            var hasGetter = property.GetMethod is { DeclaredAccessibility: Accessibility.Public };

            if (!hasSetter && !hasGetter)
                continue;

            var mapAttribute = GetFirstMatchingAttribute(property, columnAttributeNames);
            var headerName = property.Name;
            int? attributeIndex = null;
            string? format = null;

            if (mapAttribute is not null)
            {
#pragma warning disable IDE0010 // Populate switch - intentionally not exhaustive
                foreach (var arg in mapAttribute.NamedArguments)
                {
                    switch (arg.Key)
                    {
                        case "Name" when arg.Value.Value is string s && !string.IsNullOrWhiteSpace(s):
                            headerName = s;
                            break;
                        case "Index" when arg.Value.Value is int i && i >= 0:
                            attributeIndex = i;
                            break;
                        case "Format" when arg.Value.Value is string f && !string.IsNullOrWhiteSpace(f):
                            format = f;
                            break;
                    }
                }
#pragma warning restore IDE0010
            }

            if (!IsSupportedType(property.Type))
            {
                diagnostics.Add(Diagnostic.Create(
                    unsupportedPropertyTypeDiagnostic,
                    property.Locations.FirstOrDefault() ?? Location.None,
                    property.Name,
                    property.Type.ToDisplayString()));
                continue;
            }

            var typeName = property.Type.ToDisplayString(FullyQualifiedFormatWithNullable);
            var typeofTypeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var headerLiteral = EscapeString(headerName);
            var formatLiteral = format != null ? EscapeString(format) : null;

            var (baseTypeName, isNullable, isEnum) = GetBaseTypeInfo(property.Type);
            var isReadOnlyMemoryChar = IsReadOnlyMemoryChar(property.Type);

            var setterFactory = hasSetter ? CreateSetter(typeName, type, property.Name) : null;
            var getterFactory = hasGetter ? CreateGetter(type, property.Name) : null;

            members.Add(new MemberDescriptor(
                property.Name,
                headerLiteral,
                attributeIndex,
                typeName,
                typeofTypeName,
                formatLiteral,
                setterFactory,
                getterFactory,
                baseTypeName,
                isNullable,
                isEnum,
                isReadOnlyMemoryChar));
        }

        if (members.Count == 0 && diagnostics.Count == 0)
            return null;

        var fqName = type.ToDisplayString(FullyQualifiedFormatWithNullable);
        var safeClassName = CreateSafeClassName(type);
        return new TypeDescriptor(fqName, safeClassName, members, diagnostics);
    }

    private static (string baseTypeName, bool isNullable, bool isEnum) GetBaseTypeInfo(ITypeSymbol type)
    {
        var isNullable = false;
        var actualType = type;

        if (type is INamedTypeSymbol { IsGenericType: true, Name: "Nullable" } nullable)
        {
            isNullable = true;
            actualType = nullable.TypeArguments[0];
        }

        if (type.NullableAnnotation == NullableAnnotation.Annotated && type.OriginalDefinition.SpecialType == SpecialType.None)
        {
            isNullable = true;
        }

        var isEnum = actualType.TypeKind == TypeKind.Enum;
        var baseTypeName = actualType.ToDisplayString();

        return (baseTypeName, isNullable, isEnum);
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private static string CreateGetter(INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target) => target.{propertyName}";

    private sealed record TypeDescriptor(
        string FullyQualifiedName,
        string SafeClassName,
        IReadOnlyList<MemberDescriptor> Members,
        IReadOnlyList<Diagnostic> Diagnostics);

    private sealed record MemberDescriptor(
        string MemberName,
        string HeaderName,
        int? AttributeIndex,
        string TypeName,
        string TypeofTypeName,
        string? Format,
        string? SetterFactory,
        string? GetterFactory,
        string BaseTypeName,
        bool IsNullable,
        bool IsEnum,
        bool IsReadOnlyMemoryChar);
}
