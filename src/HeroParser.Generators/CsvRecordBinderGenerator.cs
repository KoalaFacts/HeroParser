using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HeroParser.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class CsvRecordBinderGenerator : IIncrementalGenerator
{
    private const string GenerateAttribute = "HeroParser.CsvGenerateBinderAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                GenerateAttribute,
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (ctx, _) => ctx.TargetSymbol as INamedTypeSymbol)
            .Where(x => x is not null)!;

        var collected = candidates.Collect();

        context.RegisterSourceOutput(collected, static (spc, symbols) => Emit(spc, symbols!));
    }

    private static void Emit(SourceProductionContext context, IReadOnlyList<INamedTypeSymbol> symbols)
    {
        if (symbols.Count == 0)
            return;

        var builder = new SourceBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using HeroParser;");
        builder.AppendLine("using HeroParser.SeparatedValues;");
        builder.AppendLine();
        builder.AppendLine("namespace HeroParser;");
        builder.AppendLine();
        builder.AppendLine("internal static partial class CsvRecordBinderFactory");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("static partial void RegisterGeneratedBinders(Dictionary<Type, Func<CsvRecordOptions?, object>> factories)");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var symbol in symbols)
        {
            if (symbol is null || symbol.IsAbstract)
                continue;

            var descriptor = BuildDescriptor(symbol);
            if (descriptor is null)
                continue;

            builder.AppendLine($"factories[typeof({descriptor.FullyQualifiedName})] = options => CsvRecordBinder<{descriptor.FullyQualifiedName}>.CreateFromTemplates(options, new CsvRecordBinder<{descriptor.FullyQualifiedName}>.BindingTemplate[]");
            builder.AppendLine("{");
            builder.Indent();

            foreach (var member in descriptor.Members)
            {
                builder.AppendLine($"new CsvRecordBinder<{descriptor.FullyQualifiedName}>.BindingTemplate(");
                builder.Indent();
                builder.AppendLine($"\"{member.MemberName}\",");
                builder.AppendLine($"typeof({member.TypeName}),");
                builder.AppendLine($"\"{member.HeaderName}\",");
                builder.AppendLine(member.AttributeIndex is null ? "null," : $"{member.AttributeIndex},");
                builder.AppendLine($"{member.ConverterFactory},");
                builder.AppendLine($"{member.SetterFactory}),");
                builder.Unindent();
            }

            builder.Unindent();
            builder.AppendLine("});");
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("CsvRecordBinderFactory.g.cs", builder.ToString());
    }

    private static TypeDescriptor? BuildDescriptor(INamedTypeSymbol type)
    {
        var members = new List<MemberDescriptor>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (property.IsStatic || property.SetMethod is null || property.SetMethod.DeclaredAccessibility != Accessibility.Public)
                continue;

            var mapAttribute = property.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "HeroParser.CsvColumnAttribute");
            var headerName = property.Name;
            int? attributeIndex = null;
            if (mapAttribute is not null)
            {
                foreach (var arg in mapAttribute.NamedArguments)
                {
                    if (arg.Key == "Name" && arg.Value.Value is string s && !string.IsNullOrWhiteSpace(s))
                        headerName = s;
                    if (arg.Key == "Index" && arg.Value.Value is int i && i >= 0)
                        attributeIndex = i;
                }
            }

            var converter = CreateConverter(property);
            if (converter is null)
                return null; // unsupported type -> skip generation for this type

            var typeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            var headerLiteral = headerName.Replace("\"", "\"\"");

            members.Add(new MemberDescriptor(
                property.Name,
                headerLiteral,
                attributeIndex,
                typeName,
                converter.Factory,
                CreateSetter(typeName, type, property.Name)));
        }

        if (members.Count == 0)
            return null;

        var fqName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        return new TypeDescriptor(fqName, members);
    }

    private static ConverterDescriptor? CreateConverter(IPropertySymbol property)
    {
        var type = property.Type;
        var isNullable = type.NullableAnnotation == NullableAnnotation.Annotated || type.IsReferenceType;
        var underlying = type is INamedTypeSymbol named && named.IsGenericType && named.Name == "Nullable" ? named.TypeArguments[0] : type;

        string? body = underlying.SpecialType switch
        {
            SpecialType.System_String => isNullable
                ? "if (column.IsEmpty) { value = null; return true; } value = column.ToString(); return true;"
                : "value = column.ToString(); return true;",
            SpecialType.System_Int32 => BuildTryParse("column.TryParseInt32", isNullable),
            SpecialType.System_Int64 => BuildTryParse("column.TryParseInt64", isNullable),
            SpecialType.System_Int16 => BuildTryParse("column.TryParseInt16", isNullable),
            SpecialType.System_Byte => BuildTryParse("column.TryParseByte", isNullable),
            SpecialType.System_UInt32 => BuildTryParse("column.TryParseUInt32", isNullable),
            SpecialType.System_UInt64 => BuildTryParse("column.TryParseUInt64", isNullable),
            SpecialType.System_UInt16 => BuildTryParse("column.TryParseUInt16", isNullable),
            SpecialType.System_SByte => BuildTryParse("column.TryParseSByte", isNullable),
            SpecialType.System_Double => BuildTryParse("column.TryParseDouble", isNullable),
            SpecialType.System_Single => BuildTryParse("column.TryParseSingle", isNullable),
            SpecialType.System_Decimal => BuildTryParse("column.TryParseDecimal", isNullable),
            SpecialType.System_Boolean => BuildTryParse("column.TryParseBoolean", isNullable),
            _ => BuildComplexConverter(underlying, isNullable)
        };

        if (body is null)
            return null;

        var factory = $"(CsvCharSpanColumn column, out object? value) => {{ {body} }}";
        return new ConverterDescriptor(factory);
    }

    private static string? BuildComplexConverter(ITypeSymbol type, bool isNullable)
    {
        var display = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return type.ToDisplayString() switch
        {
            "System.DateTime" => BuildTryParse("column.TryParseDateTime", isNullable),
            "System.DateTimeOffset" => BuildTryParse("column.TryParseDateTimeOffset", isNullable),
            "System.DateOnly" => BuildTryParse("column.TryParseDateOnly", isNullable),
            "System.TimeOnly" => BuildTryParse("column.TryParseTimeOnly", isNullable),
            "System.Guid" => BuildTryParse("column.TryParseGuid", isNullable),
            "System.TimeZoneInfo" => BuildTryParse("column.TryParseTimeZoneInfo", isNullable),
            _ when type.TypeKind == TypeKind.Enum => BuildTryParse($"column.TryParseEnum<{display}>", isNullable),
            _ => null
        };
    }

    private static string BuildTryParse(string tryParseCall, bool isNullable)
    {
        if (isNullable)
        {
            return $"if (column.IsEmpty) {{ value = null; return true; }} if ({tryParseCall}(out var parsed)) {{ value = parsed; return true; }} value = null; return false;";
        }

        return $"if ({tryParseCall}(out var parsed)) {{ value = parsed; return true; }} value = null; return false;";
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private sealed record TypeDescriptor(string FullyQualifiedName, IReadOnlyList<MemberDescriptor> Members);

    private sealed record MemberDescriptor(
        string MemberName,
        string HeaderName,
        int? AttributeIndex,
        string TypeName,
        string ConverterFactory,
        string SetterFactory);

    private sealed record ConverterDescriptor(string Factory);

    private sealed class SourceBuilder
    {
        private readonly System.Text.StringBuilder builder = new();
        private int indent;
        private const string IndentString = "    ";

        public void Indent() => indent++;
        public void Unindent() => indent = Math.Max(0, indent - 1);

        public void AppendLine(string line = "")
        {
            for (int i = 0; i < indent; i++)
                builder.Append(IndentString);
            builder.AppendLine(line);
        }

        public override string ToString() => builder.ToString();
    }
}
