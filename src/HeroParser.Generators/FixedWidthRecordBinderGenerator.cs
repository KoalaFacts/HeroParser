using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace HeroParser.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class FixedWidthRecordBinderGenerator : IIncrementalGenerator
{
    private const string GENERATED_NAMESPACE = "HeroParser.FixedWidths.Records.Binding";
    private const string BINDER_FACTORY_TYPE = "global::HeroParser.FixedWidths.Records.Binding.FixedWidthRecordBinderFactory";
    private const string WRITER_TYPE = "global::HeroParser.FixedWidths.Writing.FixedWidthRecordWriter";
    private const string WRITER_FACTORY_TYPE = "global::HeroParser.FixedWidths.Writing.FixedWidthRecordWriterFactory";
    private const string FIELD_ALIGNMENT_TYPE = "global::HeroParser.FixedWidths.FieldAlignment";
    private const string ROW_TYPE = "global::HeroParser.FixedWidths.FixedWidthCharSpanRow";
    private static readonly string[] generateAttributeNames = [
        "HeroParser.FixedWidths.Records.Binding.FixedWidthGenerateBinderAttribute",
        "HeroParser.FixedWidthGenerateBinderAttribute"
    ];
    private static readonly string[] columnAttributeNames = [
        "HeroParser.FixedWidths.Records.Binding.FixedWidthColumnAttribute",
        "HeroParser.FixedWidthColumnAttribute"
    ];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (ctx, _) =>
                {
                    if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) is not INamedTypeSymbol symbol)
                        return null;

                    return HasGenerateAttribute(symbol) ? symbol : null;
                })
            .Where(x => x is not null)
            .Select((symbol, _) => symbol!)!;

        var collected = candidates.Collect();

        context.RegisterSourceOutput(collected, static (spc, symbols) => Emit(spc, symbols!));
    }

    private static void Emit(SourceProductionContext context, IReadOnlyList<INamedTypeSymbol> symbols)
    {
        if (symbols.Count == 0)
            return;

        var builder = new SourceBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Globalization;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();

        // Emit typed binder classes for each type
        foreach (var symbol in symbols)
        {
            if (symbol is null || symbol.IsAbstract)
                continue;

            var descriptor = BuildDescriptor(context, symbol);
            if (descriptor is null)
                continue;

            var binderMembers = descriptor.Members.Where(m => m.SetterFactory != null).ToList();
            if (binderMembers.Count > 0)
            {
                EmitTypedBinderClass(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName, binderMembers);
            }
        }

        // Emit registration class
        builder.AppendLine("file static class FixedWidthRecordBinderGeneratedRegistration");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("[ModuleInitializer]");
        builder.AppendLine("internal static void Register()");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var symbol in symbols)
        {
            if (symbol is null || symbol.IsAbstract)
                continue;

            var descriptor = BuildDescriptor(context, symbol);
            if (descriptor is null)
                continue;

            // Register binder (for reading - members with setters)
            var binderMembers = descriptor.Members.Where(m => m.SetterFactory != null).ToList();
            if (binderMembers.Count > 0)
            {
                EmitBinderRegistration(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName);
            }

            // Register writer (for writing - members with getters)
            var writerMembers = descriptor.Members.Where(m => m.GetterFactory != null).ToList();
            if (writerMembers.Count > 0)
            {
                EmitWriterRegistration(builder, descriptor.FullyQualifiedName, writerMembers);
            }
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("FixedWidthRecordBinderFactory.g.cs", builder.ToString());
    }

    private static void EmitTypedBinderClass(SourceBuilder builder, string fullyQualifiedName, string safeClassName, IReadOnlyList<MemberDescriptor> members)
    {
        var binderClassName = $"TypedBinder_{safeClassName}";

        builder.AppendLine($"file sealed class {binderClassName} : global::HeroParser.FixedWidths.Records.Binding.ITypedBinder<{fullyQualifiedName}>");
        builder.AppendLine("{");
        builder.Indent();

        // Fields for configuration
        builder.AppendLine("private readonly CultureInfo culture;");
        builder.AppendLine("private readonly HashSet<string>? nullValues;");
        builder.AppendLine();

        // Constructor
        builder.AppendLine($"public {binderClassName}(CultureInfo? culture, IReadOnlyList<string>? nullValues)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("this.culture = culture ?? CultureInfo.InvariantCulture;");
        builder.AppendLine("this.nullValues = nullValues is { Count: > 0 } ? new HashSet<string>(nullValues, StringComparer.Ordinal) : null;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // Bind method - fully typed, no boxing
        builder.AppendLine($"public {fullyQualifiedName}? Bind({ROW_TYPE} row)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine($"var instance = new {fullyQualifiedName}();");
        builder.AppendLine();

        foreach (var member in members)
        {
            var fieldVar = $"field_{member.MemberName}";
            var spanVar = $"span_{member.MemberName}";

            builder.AppendLine($"// {member.MemberName}");
            builder.AppendLine($"var {fieldVar} = row.GetField({member.Start}, {member.Length}, '{EscapeChar(member.PadChar)}', {FIELD_ALIGNMENT_TYPE}.{member.Alignment});");
            builder.AppendLine($"var {spanVar} = {fieldVar}.CharSpan;");

            // Null value check
            builder.AppendLine($"if (nullValues is null || !IsNullValue({spanVar}))");
            builder.AppendLine("{");
            builder.Indent();

            // Generate type-specific parsing code (throws on parse failure)
            EmitTypedParsing(builder, member, spanVar, fieldVar);

            builder.Unindent();
            builder.AppendLine("}");
            builder.AppendLine();
        }

        builder.AppendLine("return instance;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // BindInto method - binds into an existing instance to avoid object allocation
        builder.AppendLine($"public bool BindInto({fullyQualifiedName} instance, {ROW_TYPE} row)");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            var fieldVar = $"field_{member.MemberName}";
            var spanVar = $"span_{member.MemberName}";

            builder.AppendLine($"// {member.MemberName}");
            builder.AppendLine($"var {fieldVar} = row.GetField({member.Start}, {member.Length}, '{EscapeChar(member.PadChar)}', {FIELD_ALIGNMENT_TYPE}.{member.Alignment});");
            builder.AppendLine($"var {spanVar} = {fieldVar}.CharSpan;");

            // Null value check
            builder.AppendLine($"if (nullValues is null || !IsNullValue({spanVar}))");
            builder.AppendLine("{");
            builder.Indent();

            // Generate type-specific parsing code (throws on parse failure)
            EmitTypedParsing(builder, member, spanVar, fieldVar);

            builder.Unindent();
            builder.AppendLine("}");
            builder.AppendLine();
        }

        builder.AppendLine("return true;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // IsNullValue helper
        builder.AppendLine("private bool IsNullValue(ReadOnlySpan<char> span)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (nullValues is null) return false;");
        builder.AppendLine("foreach (var nv in nullValues)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (span.SequenceEqual(nv.AsSpan())) return true;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine("return false;");
        builder.Unindent();
        builder.AppendLine("}");

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();
    }

    private static void EmitTypedParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar)
    {
        var baseType = member.BaseTypeName;
        var isNullable = member.IsNullable;
        var propertyName = member.MemberName;

        // Handle each supported type with direct parsing (no boxing)
        switch (baseType)
        {
            case "string":
                builder.AppendLine($"instance.{propertyName} = new string({spanVar});");
                break;

            case "int":
            case "System.Int32":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "int", "Integer");
                break;

            case "long":
            case "System.Int64":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "long", "Integer");
                break;

            case "short":
            case "System.Int16":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "short", "Integer");
                break;

            case "byte":
            case "System.Byte":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "byte", "Integer");
                break;

            case "decimal":
            case "System.Decimal":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "decimal", "Number");
                break;

            case "double":
            case "System.Double":
                EmitFloatParsing(builder, member, spanVar, fieldVar, "double");
                break;

            case "float":
            case "System.Single":
                EmitFloatParsing(builder, member, spanVar, fieldVar, "float");
                break;

            case "bool":
            case "System.Boolean":
                EmitBooleanParsing(builder, member, spanVar, fieldVar);
                break;

            case "System.DateTime":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "DateTime");
                break;

            case "System.DateTimeOffset":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "DateTimeOffset");
                break;

            case "System.DateOnly":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "DateOnly");
                break;

            case "System.TimeOnly":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "TimeOnly");
                break;

            case "System.Guid":
                EmitGuidParsing(builder, member, spanVar, fieldVar);
                break;

            default:
                // For enums and other types, fall back to string conversion
                if (member.IsEnum)
                {
                    EmitEnumParsing(builder, member, spanVar, fieldVar, isNullable);
                }
                else
                {
                    // Unsupported - use string
                    builder.AppendLine($"instance.{propertyName} = new string({spanVar});");
                }
                break;
        }
    }

    private static void EmitFloatParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, string typeName)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        var styles = "NumberStyles.Float | NumberStyles.AllowThousands";

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
        else
        {
            builder.AppendLine($"if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
    }

    private static void EmitBooleanParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if (bool.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine($"else if ({spanVar}.Length == 1)");
            builder.AppendLine("{");
            builder.Indent();
            builder.AppendLine($"var c = {spanVar}[0];");
            builder.AppendLine($"if (c is '1' or 'Y' or 'y' or 'T' or 't') instance.{propertyName} = true;");
            builder.AppendLine($"else if (c is '0' or 'N' or 'n' or 'F' or 'f') instance.{propertyName} = false;");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
            builder.Unindent();
            builder.AppendLine("}");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
        }
        else
        {
            builder.AppendLine($"if (bool.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine($"else if ({spanVar}.Length == 1)");
            builder.AppendLine("{");
            builder.Indent();
            builder.AppendLine($"var c = {spanVar}[0];");
            builder.AppendLine($"if (c is '1' or 'Y' or 'y' or 'T' or 't') instance.{propertyName} = true;");
            builder.AppendLine($"else if (c is '0' or 'N' or 'n' or 'F' or 'f') instance.{propertyName} = false;");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
            builder.Unindent();
            builder.AppendLine("}");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
        }
    }

    private static void EmitDateTimeParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, string typeName)
    {
        var propertyName = member.MemberName;
        var format = member.Format;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            if (format != null)
            {
                builder.AppendLine($"else if ({typeName}.TryParseExact({spanVar}, \"{EscapeString(format)}\", culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            else
            {
                builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
        else
        {
            if (format != null)
            {
                builder.AppendLine($"if ({typeName}.TryParseExact({spanVar}, \"{EscapeString(format)}\", culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            else
            {
                builder.AppendLine($"if ({typeName}.TryParse({spanVar}, culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
    }

    private static void EmitGuidParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if (Guid.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "Guid");
        }
        else
        {
            builder.AppendLine($"if (Guid.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "Guid");
        }
    }

    private static void EmitEnumParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, bool isNullable)
    {
        var propertyName = member.MemberName;
        var enumType = member.TypeofTypeName;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if (Enum.TryParse<{enumType}>({spanVar}, ignoreCase: true, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, enumType);
        }
        else
        {
            builder.AppendLine($"if (Enum.TryParse<{enumType}>({spanVar}, ignoreCase: true, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, enumType);
        }
    }

    private static void EmitNumericParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, string typeName, string numberStyle)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        var styles = numberStyle == "Integer" ? "NumberStyles.Integer" : "NumberStyles.Number";

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
        else
        {
            builder.AppendLine($"if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
    }

    private static void EmitThrowParseError(SourceBuilder builder, string propertyName, string fieldVar, string typeName)
    {
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("throw new global::HeroParser.FixedWidths.FixedWidthException(");
        builder.AppendLine("    global::HeroParser.FixedWidths.FixedWidthErrorCode.ParseError,");
        builder.AppendLine("    $\"Failed to convert field '" + propertyName + "' value '{" + fieldVar + ".ToString()}' to " + typeName + ".\",");
        builder.AppendLine("    row.RecordNumber,");
        builder.AppendLine("    row.SourceLineNumber);");
        builder.Unindent();
        builder.AppendLine("}");
    }

    private static void EmitBinderRegistration(SourceBuilder builder, string fullyQualifiedName, string safeClassName)
    {
        var binderClassName = $"TypedBinder_{safeClassName}";
        builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterTypedBinder<{fullyQualifiedName}>((culture, nullValues) => new {binderClassName}(culture, nullValues));");
    }

    private static void EmitWriterRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{WRITER_FACTORY_TYPE}.RegisterGeneratedWriter(typeof({fullyQualifiedName}), options => {WRITER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeofTypeName}),");
            builder.AppendLine($"{member.Start},");
            builder.AppendLine($"{member.Length},");
            builder.AppendLine($"{FIELD_ALIGNMENT_TYPE}.{member.Alignment},");
            builder.AppendLine($"'{EscapeChar(member.PadChar)}',");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.GetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static TypeDescriptor? BuildDescriptor(SourceProductionContext context, INamedTypeSymbol type)
    {
        // Skip types that are not publicly accessible (private, internal nested, etc.)
        if (!IsTypeAccessible(type))
            return null;

        var members = new List<MemberDescriptor>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (property.IsStatic)
                continue;

            // Check accessibility - need at least one of getter/setter to be public
            var hasSetter = property.SetMethod is { DeclaredAccessibility: Accessibility.Public };
            var hasGetter = property.GetMethod is { DeclaredAccessibility: Accessibility.Public };

            // Skip if neither getter nor setter is public
            if (!hasSetter && !hasGetter)
                continue;

            var mapAttribute = GetFirstMatchingAttribute(property, columnAttributeNames);
            if (mapAttribute is null)
                continue;

            int start = 0;
            int length = 0;
            char padChar = '\0';
            string alignment = "Left";
            string? format = null;

            foreach (var arg in mapAttribute.NamedArguments)
            {
                if (arg.Key == "Start" && arg.Value.Value is int s)
                    start = s;
                if (arg.Key == "Length" && arg.Value.Value is int l)
                    length = l;
                if (arg.Key == "PadChar" && arg.Value.Value is char p)
                    padChar = p;
                if (arg.Key == "Alignment" && arg.Value.Value is int a)
                    alignment = GetAlignmentName(a);
                if (arg.Key == "Format" && arg.Value.Value is string f && !string.IsNullOrWhiteSpace(f))
                    format = f;
            }

            // Constructor arguments take precedence
            if (mapAttribute.ConstructorArguments.Length >= 1 && mapAttribute.ConstructorArguments[0].Value is int startArg)
                start = startArg;
            if (mapAttribute.ConstructorArguments.Length >= 2 && mapAttribute.ConstructorArguments[1].Value is int lengthArg)
                length = lengthArg;

            // Check if type is supported (for diagnostic reporting)
            if (!IsSupportedType(property.Type))
            {
                // Report diagnostic for unsupported property type
                var diagnostic = Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "HERO002",
                        "Unsupported property type",
                        "Property '{0}' of type '{1}' is not supported by the fixed-width record binder generator. Supported types include primitives, DateTime, DateTimeOffset, DateOnly, TimeOnly, Guid, and enums.",
                        "HeroParser.Generators",
                        DiagnosticSeverity.Warning,
                        isEnabledByDefault: true),
                    property.Locations.FirstOrDefault() ?? Location.None,
                    property.Name,
                    property.Type.ToDisplayString());
                context.ReportDiagnostic(diagnostic);
                continue; // Skip this property but continue with others
            }

            // Type name with nullable modifiers for setter cast
            var typeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            // Type name without nullable modifiers for typeof() - strip trailing ?
            var typeofTypeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var formatLiteral = format != null ? EscapeString(format) : null;

            // Get base type info for typed parsing
            var (baseTypeName, isNullable, isEnum) = GetBaseTypeInfo(property.Type);

            // Default pad char to space if not specified
            if (padChar == '\0')
                padChar = ' ';

            // Generate setter only if property has public setter (for binder/reader)
            string? setterFactory = hasSetter ? CreateSetter(typeName, type, property.Name) : null;

            // Generate getter only if property has public getter (for writer)
            string? getterFactory = hasGetter ? CreateGetter(type, property.Name) : null;

            members.Add(new MemberDescriptor(
                property.Name,
                start,
                length,
                padChar,
                alignment,
                typeName,
                typeofTypeName,
                formatLiteral,
                setterFactory,
                getterFactory,
                baseTypeName,
                isNullable,
                isEnum));
        }

        if (members.Count == 0)
            return null;

        // Sort by Start position
        var sortedMembers = members.OrderBy(m => m.Start).ToArray();

        var fqName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        // Create a safe class name for the generated binder (handles nested types, generics, etc.)
        var safeClassName = CreateSafeClassName(type);
        return new TypeDescriptor(fqName, safeClassName, sortedMembers);
    }

    private static (string baseTypeName, bool isNullable, bool isEnum) GetBaseTypeInfo(ITypeSymbol type)
    {
        var isNullable = false;
        var actualType = type;

        // Handle Nullable<T>
        if (type is INamedTypeSymbol { IsGenericType: true, Name: "Nullable" } nullable)
        {
            isNullable = true;
            actualType = nullable.TypeArguments[0];
        }

        // Handle nullable reference types (string?)
        if (type.NullableAnnotation == NullableAnnotation.Annotated && type.OriginalDefinition.SpecialType == SpecialType.None)
        {
            isNullable = true;
        }

        var isEnum = actualType.TypeKind == TypeKind.Enum;
        var baseTypeName = actualType.ToDisplayString();

        return (baseTypeName, isNullable, isEnum);
    }

    private static string CreateSafeClassName(INamedTypeSymbol type)
    {
        // Create a safe identifier from the type name (handles nested types, namespaces, generics)
        var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace(".", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", "");
        return name;
    }

    private static string GetAlignmentName(int value)
    {
        return value switch
        {
            0 => "Left",
            1 => "Right",
            2 => "Center",
            3 => "None",
            _ => "Left"
        };
    }

    private static bool IsSupportedType(ITypeSymbol type)
    {
        var underlying = type is INamedTypeSymbol named && named.IsGenericType && named.Name == "Nullable"
            ? named.TypeArguments[0]
            : type;

        return underlying.SpecialType switch
        {
            SpecialType.System_String => true,
            SpecialType.System_Int32 => true,
            SpecialType.System_Int64 => true,
            SpecialType.System_Int16 => true,
            SpecialType.System_Byte => true,
            SpecialType.System_UInt32 => true,
            SpecialType.System_UInt64 => true,
            SpecialType.System_UInt16 => true,
            SpecialType.System_SByte => true,
            SpecialType.System_Double => true,
            SpecialType.System_Single => true,
            SpecialType.System_Decimal => true,
            SpecialType.System_Boolean => true,
            _ => IsSupportedComplexType(underlying)
        };
    }

    private static bool IsSupportedComplexType(ITypeSymbol type)
    {
        return type.ToDisplayString() switch
        {
            "System.DateTime" => true,
            "System.DateTimeOffset" => true,
            "System.DateOnly" => true,
            "System.TimeOnly" => true,
            "System.Guid" => true,
            _ when type.TypeKind == TypeKind.Enum => true,
            _ => false
        };
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private static string CreateGetter(INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target) => target.{propertyName}";

    private static string EscapeString(string value)
    {
        // Escape backslashes and quotes for C# string literals
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static string EscapeChar(char c)
    {
        return c switch
        {
            '\'' => "\\'",
            '\\' => "\\\\",
            '\0' => "\\0",
            '\n' => "\\n",
            '\r' => "\\r",
            '\t' => "\\t",
            _ => c.ToString()
        };
    }

    private static bool HasGenerateAttribute(INamedTypeSymbol symbol)
        => symbol.GetAttributes().Any(attr => IsNamed(attr, generateAttributeNames));

    private static AttributeData? GetFirstMatchingAttribute(ISymbol symbol, IReadOnlyList<string> names)
        => symbol.GetAttributes().FirstOrDefault(attr => IsNamed(attr, names));

    private static bool IsNamed(AttributeData attribute, IReadOnlyList<string> names)
    {
        var name = attribute.AttributeClass?.ToDisplayString();
        if (name is null)
            return false;

        foreach (var candidate in names)
        {
            if (string.Equals(name, candidate, StringComparison.Ordinal))
                return true;
        }

        return false;
    }

    private static bool IsTypeAccessible(INamedTypeSymbol type)
    {
        // Check if the type itself and all containing types are at least internal
        var current = type;
        while (current is not null)
        {
            if (current.DeclaredAccessibility == Accessibility.Private ||
                current.DeclaredAccessibility == Accessibility.Protected ||
                current.DeclaredAccessibility == Accessibility.ProtectedAndInternal)
            {
                return false;
            }
            current = current.ContainingType;
        }
        return true;
    }

    private sealed record TypeDescriptor(string FullyQualifiedName, string SafeClassName, IReadOnlyList<MemberDescriptor> Members);

    private sealed record MemberDescriptor(
        string MemberName,
        int Start,
        int Length,
        char PadChar,
        string Alignment,
        string TypeName,
        string TypeofTypeName,
        string? Format,
        string? SetterFactory,
        string? GetterFactory,
        string BaseTypeName,
        bool IsNullable,
        bool IsEnum);

    private sealed class SourceBuilder
    {
        private readonly System.Text.StringBuilder builder = new();
        private int indent;
        private const string INDENT_STRING = "    ";

        public void Indent() => indent++;
        public void Unindent() => indent = Math.Max(0, indent - 1);

        public void AppendLine(string line = "")
        {
            for (int i = 0; i < indent; i++)
                builder.Append(INDENT_STRING);
            builder.AppendLine(line);
        }

        public override string ToString() => builder.ToString();
    }
}
