using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using static HeroParser.Generators.GeneratorHelpers;

namespace HeroParser.Generators;

/// <summary>
/// Source generator for fixed-width record binders.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class FixedWidthRecordBinderGenerator : IIncrementalGenerator
{
    private const string GENERATED_NAMESPACE = "HeroParser.FixedWidths.Records.Binding";
    private const string BINDER_FACTORY_TYPE = "global::HeroParser.FixedWidths.Records.Binding.FixedWidthRecordBinderFactory";
    private const string WRITER_TYPE = "global::HeroParser.FixedWidths.Writing.FixedWidthRecordWriter";
    private const string WRITER_FACTORY_TYPE = "global::HeroParser.FixedWidths.Writing.FixedWidthRecordWriterFactory";
    private const string FIELD_ALIGNMENT_TYPE = "global::HeroParser.FixedWidths.FieldAlignment";
    private const string ROW_TYPE = "global::HeroParser.FixedWidths.FixedWidthCharSpanRow";

    private static readonly string[] generateAttributeNames =
    [
        "HeroParser.FixedWidths.Records.Binding.FixedWidthGenerateBinderAttribute",
        "HeroParser.FixedWidthGenerateBinderAttribute"
    ];

    private static readonly string[] columnAttributeNames =
    [
        "HeroParser.FixedWidths.Records.Binding.FixedWidthColumnAttribute",
        "HeroParser.FixedWidthColumnAttribute"
    ];

#pragma warning disable RS2008 // Enable analyzer release tracking - not needed for internal generator
    private static readonly DiagnosticDescriptor unsupportedPropertyTypeDiagnostic = new(
        "HERO002",
        "Unsupported property type",
        "Property '{0}' of type '{1}' is not supported by the fixed-width record binder generator. Supported types include primitives, DateTime, DateTimeOffset, DateOnly, TimeOnly, Guid, and enums.",
        "HeroParser.Generators",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);
#pragma warning restore RS2008

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Use ForAttributeWithMetadataName for better caching - register for both attribute names
        var provider1 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[0],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        var provider2 = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                generateAttributeNames[1],
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, ct) => TransformToDescriptor(ctx, ct))
            .Where(static x => x is not null);

        // Combine both providers
        var combined = provider1.Collect().Combine(provider2.Collect());

        // Generate per-type binder files for better incrementality
        context.RegisterSourceOutput(provider1, static (spc, descriptor) => EmitTypedBinder(spc, descriptor!));
        context.RegisterSourceOutput(provider2, static (spc, descriptor) => EmitTypedBinder(spc, descriptor!));

        // Generate registration file
        context.RegisterSourceOutput(combined, static (spc, tuple) =>
        {
            var all = tuple.Left.Concat(tuple.Right).Where(x => x is not null).ToList();
            if (all.Count > 0)
                EmitRegistration(spc, all!);
        });
    }

    private static TypeDescriptor? TransformToDescriptor(GeneratorAttributeSyntaxContext ctx, CancellationToken ct)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;

        if (symbol.IsAbstract || !IsTypeAccessible(symbol))
            return null;

        return BuildDescriptor(symbol, ct);
    }

    private static void EmitTypedBinder(SourceProductionContext context, TypeDescriptor descriptor)
    {
        // Report diagnostics
        foreach (var diag in descriptor.Diagnostics)
        {
            context.ReportDiagnostic(diag);
        }

        var binderMembers = GetMembersWithSetters(descriptor.Members);
        if (binderMembers.Count == 0)
            return;

        var builder = new SourceBuilder(8192);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Globalization;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();

        EmitTypedBinderClass(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName, binderMembers);

        context.AddSource($"FixedWidthBinder.{descriptor.SafeClassName}.g.cs", builder.ToString());
    }

    private static void EmitRegistration(SourceProductionContext context, IReadOnlyList<TypeDescriptor> descriptors)
    {
        var builder = new SourceBuilder(8192);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine();
        builder.AppendLine($"namespace {GENERATED_NAMESPACE};");
        builder.AppendLine();
        builder.AppendLine("file static class FixedWidthRecordBinderGeneratedRegistration");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("[ModuleInitializer]");
        builder.AppendLine("internal static void Register()");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var descriptor in descriptors)
        {
            var binderMembers = GetMembersWithSetters(descriptor.Members);
            if (binderMembers.Count > 0)
            {
                EmitBinderRegistration(builder, descriptor.FullyQualifiedName, descriptor.SafeClassName);
            }

            var writerMembers = GetMembersWithGetters(descriptor.Members);
            if (writerMembers.Count > 0)
            {
                EmitWriterRegistration(builder, descriptor.FullyQualifiedName, writerMembers);
            }
        }

        builder.Unindent();
        builder.AppendLine("}");
        builder.Unindent();
        builder.AppendLine("}");

        context.AddSource("FixedWidthRecordBinderFactory.Registration.g.cs", builder.ToString());
    }

    private static List<MemberDescriptor> GetMembersWithSetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.SetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static List<MemberDescriptor> GetMembersWithGetters(IReadOnlyList<MemberDescriptor> members)
    {
        var result = new List<MemberDescriptor>(members.Count);
        foreach (var m in members)
        {
            if (m.GetterFactory != null)
                result.Add(m);
        }
        return result;
    }

    private static void EmitTypedBinderClass(SourceBuilder builder, string fullyQualifiedName, string safeClassName, IReadOnlyList<MemberDescriptor> members)
    {
        var binderClassName = $"TypedBinder_{safeClassName}";

        // Use internal (not file) so the registration file can reference this class
        builder.AppendLine($"internal sealed class {binderClassName} : global::HeroParser.FixedWidths.Records.Binding.ITypedBinder<{fullyQualifiedName}>");
        builder.AppendLine("{");
        builder.Indent();

        // Fields for configuration
        builder.AppendLine("private readonly CultureInfo culture;");
        builder.AppendLine("private readonly HashSet<string>? nullValues;");
        builder.AppendLine();

        // Constructor
        builder.AppendLine($"public {binderClassName}(CultureInfo? culture, IReadOnlyList<string>? nullValues)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("this.culture = culture ?? CultureInfo.InvariantCulture;");
        builder.AppendLine("this.nullValues = nullValues is { Count: > 0 } ? new HashSet<string>(nullValues, StringComparer.Ordinal) : null;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // Bind method
        builder.AppendLine($"public {fullyQualifiedName}? Bind({ROW_TYPE} row)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine($"var instance = new {fullyQualifiedName}();");
        builder.AppendLine();

        foreach (var member in members)
        {
            EmitMemberBinding(builder, member);
        }

        builder.AppendLine("return instance;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // BindInto method
        builder.AppendLine($"public bool BindInto({fullyQualifiedName} instance, {ROW_TYPE} row)");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            EmitMemberBinding(builder, member);
        }

        builder.AppendLine("return true;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();

        // IsNullValue helper
        builder.AppendLine("private bool IsNullValue(ReadOnlySpan<char> span)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (nullValues is null) return false;");
        builder.AppendLine("foreach (var nv in nullValues)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("if (span.SequenceEqual(nv.AsSpan())) return true;");
        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine("return false;");
        builder.Unindent();
        builder.AppendLine("}");

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();
    }

    private static void EmitMemberBinding(SourceBuilder builder, MemberDescriptor member)
    {
        var fieldVar = $"field_{member.MemberName}";
        var spanVar = $"span_{member.MemberName}";

        builder.AppendLine($"// {member.MemberName}");
        builder.AppendLine($"var {fieldVar} = row.GetField({member.Start}, {member.Length}, '{EscapeChar(member.PadChar)}', {FIELD_ALIGNMENT_TYPE}.{member.Alignment});");
        builder.AppendLine($"var {spanVar} = {fieldVar}.CharSpan;");

        builder.AppendLine($"if (nullValues is null || !IsNullValue({spanVar}))");
        builder.AppendLine("{");
        builder.Indent();

        EmitTypedParsing(builder, member, spanVar, fieldVar);

        builder.Unindent();
        builder.AppendLine("}");
        builder.AppendLine();
    }

    private static void EmitTypedParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar)
    {
        var baseType = member.BaseTypeName;
        var isNullable = member.IsNullable;
        var propertyName = member.MemberName;

#pragma warning disable IDE0010 // Populate switch - intentionally not exhaustive
        switch (baseType)
        {
            case "string":
                builder.AppendLine($"instance.{propertyName} = new string({spanVar});");
                break;

            case "int":
            case "System.Int32":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "int", "Integer");
                break;

            case "long":
            case "System.Int64":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "long", "Integer");
                break;

            case "short":
            case "System.Int16":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "short", "Integer");
                break;

            case "byte":
            case "System.Byte":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "byte", "Integer");
                break;

            case "decimal":
            case "System.Decimal":
                EmitNumericParsing(builder, member, spanVar, fieldVar, "decimal", "Number");
                break;

            case "double":
            case "System.Double":
                EmitFloatParsing(builder, member, spanVar, fieldVar, "double");
                break;

            case "float":
            case "System.Single":
                EmitFloatParsing(builder, member, spanVar, fieldVar, "float");
                break;

            case "bool":
            case "System.Boolean":
                EmitBooleanParsing(builder, member, spanVar, fieldVar);
                break;

            case "System.DateTime":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "DateTime");
                break;

            case "System.DateTimeOffset":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "DateTimeOffset");
                break;

            case "System.DateOnly":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "DateOnly");
                break;

            case "System.TimeOnly":
                EmitDateTimeParsing(builder, member, spanVar, fieldVar, "TimeOnly");
                break;

            case "System.Guid":
                EmitGuidParsing(builder, member, spanVar, fieldVar);
                break;

            default:
                if (member.IsEnum)
                {
                    EmitEnumParsing(builder, member, spanVar, fieldVar, isNullable);
                }
                else
                {
                    builder.AppendLine($"instance.{propertyName} = new string({spanVar});");
                }
                break;
        }
#pragma warning restore IDE0010
    }

    private static void EmitFloatParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, string typeName)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        const string STYLES = "NumberStyles.Float | NumberStyles.AllowThousands";

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, {STYLES}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
        else
        {
            builder.AppendLine($"if ({typeName}.TryParse({spanVar}, {STYLES}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
    }

    private static void EmitBooleanParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if (bool.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine($"else if ({spanVar}.Length == 1)");
            builder.AppendLine("{");
            builder.Indent();
            builder.AppendLine($"var c = {spanVar}[0];");
            builder.AppendLine($"if (c is '1' or 'Y' or 'y' or 'T' or 't') instance.{propertyName} = true;");
            builder.AppendLine($"else if (c is '0' or 'N' or 'n' or 'F' or 'f') instance.{propertyName} = false;");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
            builder.Unindent();
            builder.AppendLine("}");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
        }
        else
        {
            builder.AppendLine($"if (bool.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine($"else if ({spanVar}.Length == 1)");
            builder.AppendLine("{");
            builder.Indent();
            builder.AppendLine($"var c = {spanVar}[0];");
            builder.AppendLine($"if (c is '1' or 'Y' or 'y' or 'T' or 't') instance.{propertyName} = true;");
            builder.AppendLine($"else if (c is '0' or 'N' or 'n' or 'F' or 'f') instance.{propertyName} = false;");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
            builder.Unindent();
            builder.AppendLine("}");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "bool");
        }
    }

    private static void EmitDateTimeParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, string typeName)
    {
        var propertyName = member.MemberName;
        var format = member.Format;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            if (format != null)
            {
                builder.AppendLine($"else if ({typeName}.TryParseExact({spanVar}, \"{EscapeString(format)}\", culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            else
            {
                builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
        else
        {
            if (format != null)
            {
                builder.AppendLine($"if ({typeName}.TryParseExact({spanVar}, \"{EscapeString(format)}\", culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            else
            {
                builder.AppendLine($"if ({typeName}.TryParse({spanVar}, culture, DateTimeStyles.None, out var parsed_{propertyName}))");
            }
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
    }

    private static void EmitGuidParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if (Guid.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "Guid");
        }
        else
        {
            builder.AppendLine($"if (Guid.TryParse({spanVar}, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, "Guid");
        }
    }

    private static void EmitEnumParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, bool isNullable)
    {
        var propertyName = member.MemberName;
        var enumType = member.TypeofTypeName;

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if (Enum.TryParse<{enumType}>({spanVar}, ignoreCase: true, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, enumType);
        }
        else
        {
            builder.AppendLine($"if (Enum.TryParse<{enumType}>({spanVar}, ignoreCase: true, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, enumType);
        }
    }

    private static void EmitNumericParsing(SourceBuilder builder, MemberDescriptor member, string spanVar, string fieldVar, string typeName, string numberStyle)
    {
        var propertyName = member.MemberName;
        var isNullable = member.IsNullable;
        var styles = numberStyle == "Integer" ? "NumberStyles.Integer" : "NumberStyles.Number";

        if (isNullable)
        {
            builder.AppendLine($"if ({spanVar}.IsEmpty || {spanVar}.IsWhiteSpace()) {{ /* null */ }}");
            builder.AppendLine($"else if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
        else
        {
            builder.AppendLine($"if ({typeName}.TryParse({spanVar}, {styles}, culture, out var parsed_{propertyName}))");
            builder.AppendLine($"    instance.{propertyName} = parsed_{propertyName};");
            builder.AppendLine("else");
            EmitThrowParseError(builder, propertyName, fieldVar, typeName);
        }
    }

    private static void EmitThrowParseError(SourceBuilder builder, string propertyName, string fieldVar, string typeName)
    {
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("throw new global::HeroParser.FixedWidths.FixedWidthException(");
        builder.AppendLine("    global::HeroParser.FixedWidths.FixedWidthErrorCode.ParseError,");
        builder.AppendLine("    $\"Failed to convert field '" + propertyName + "' value '{" + fieldVar + ".ToString()}' to " + typeName + ".\",");
        builder.AppendLine("    row.RecordNumber,");
        builder.AppendLine("    row.SourceLineNumber);");
        builder.Unindent();
        builder.AppendLine("}");
    }

    private static void EmitBinderRegistration(SourceBuilder builder, string fullyQualifiedName, string safeClassName)
    {
        var binderClassName = $"TypedBinder_{safeClassName}";
        builder.AppendLine($"{BINDER_FACTORY_TYPE}.RegisterTypedBinder<{fullyQualifiedName}>((culture, nullValues) => new {binderClassName}(culture, nullValues));");
    }

    private static void EmitWriterRegistration(SourceBuilder builder, string fullyQualifiedName, IReadOnlyList<MemberDescriptor> members)
    {
        builder.AppendLine($"{WRITER_FACTORY_TYPE}.RegisterGeneratedWriter(typeof({fullyQualifiedName}), options => {WRITER_TYPE}<{fullyQualifiedName}>.CreateFromTemplates(options, new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate[]");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var member in members)
        {
            builder.AppendLine($"new {WRITER_TYPE}<{fullyQualifiedName}>.WriterTemplate(");
            builder.Indent();
            builder.AppendLine($"\"{member.MemberName}\",");
            builder.AppendLine($"typeof({member.TypeofTypeName}),");
            builder.AppendLine($"{member.Start},");
            builder.AppendLine($"{member.Length},");
            builder.AppendLine($"{FIELD_ALIGNMENT_TYPE}.{member.Alignment},");
            builder.AppendLine($"'{EscapeChar(member.PadChar)}',");
            builder.AppendLine(member.Format is null ? "null," : $"\"{member.Format}\",");
            builder.AppendLine($"{member.GetterFactory}),");
            builder.Unindent();
        }

        builder.Unindent();
        builder.AppendLine("}));");
        builder.AppendLine();
    }

    private static TypeDescriptor? BuildDescriptor(INamedTypeSymbol type, CancellationToken ct)
    {
        var members = new List<MemberDescriptor>();
        var diagnostics = new List<Diagnostic>();

        foreach (var property in type.GetMembers().OfType<IPropertySymbol>())
        {
            ct.ThrowIfCancellationRequested();

            if (property.IsStatic)
                continue;

            var hasSetter = property.SetMethod is { DeclaredAccessibility: Accessibility.Public };
            var hasGetter = property.GetMethod is { DeclaredAccessibility: Accessibility.Public };

            if (!hasSetter && !hasGetter)
                continue;

            var mapAttribute = GetFirstMatchingAttribute(property, columnAttributeNames);
            if (mapAttribute is null)
                continue;

            int start = 0;
            int length = 0;
            int end = -1;
            char padChar = '\0';
            string alignment = "Left";
            string? format = null;

#pragma warning disable IDE0010 // Populate switch - intentionally not exhaustive
            foreach (var arg in mapAttribute.NamedArguments)
            {
                switch (arg.Key)
                {
                    case "Start" when arg.Value.Value is int s:
                        start = s;
                        break;
                    case "Length" when arg.Value.Value is int l:
                        length = l;
                        break;
                    case "End" when arg.Value.Value is int e:
                        end = e;
                        break;
                    case "PadChar" when arg.Value.Value is char p:
                        padChar = p;
                        break;
                    case "Alignment" when arg.Value.Value is int a:
                        alignment = GetAlignmentName(a);
                        break;
                    case "Format" when arg.Value.Value is string f && !string.IsNullOrWhiteSpace(f):
                        format = f;
                        break;
                }
            }
#pragma warning restore IDE0010

            // If End is specified but Length is not, calculate Length from End - Start
            if (length == 0 && end > start)
                length = end - start;

            // Constructor arguments take precedence
            if (mapAttribute.ConstructorArguments.Length >= 1 && mapAttribute.ConstructorArguments[0].Value is int startArg)
                start = startArg;
            if (mapAttribute.ConstructorArguments.Length >= 2 && mapAttribute.ConstructorArguments[1].Value is int lengthArg)
                length = lengthArg;

            if (!IsSupportedType(property.Type))
            {
                diagnostics.Add(Diagnostic.Create(
                    unsupportedPropertyTypeDiagnostic,
                    property.Locations.FirstOrDefault() ?? Location.None,
                    property.Name,
                    property.Type.ToDisplayString()));
                continue;
            }

            var typeName = property.Type.ToDisplayString(FullyQualifiedFormatWithNullable);
            var typeofTypeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var formatLiteral = format != null ? EscapeString(format) : null;

            var (baseTypeName, isNullable, isEnum) = GetBaseTypeInfo(property.Type);

            if (padChar == '\0')
                padChar = ' ';

            var setterFactory = hasSetter ? CreateSetter(typeName, type, property.Name) : null;
            var getterFactory = hasGetter ? CreateGetter(type, property.Name) : null;

            members.Add(new MemberDescriptor(
                property.Name,
                start,
                length,
                padChar,
                alignment,
                typeName,
                typeofTypeName,
                formatLiteral,
                setterFactory,
                getterFactory,
                baseTypeName,
                isNullable,
                isEnum));
        }

        if (members.Count == 0 && diagnostics.Count == 0)
            return null;

        // Sort by Start position
        members.Sort((a, b) => a.Start.CompareTo(b.Start));

        var fqName = type.ToDisplayString(FullyQualifiedFormatWithNullable);
        var safeClassName = CreateSafeClassName(type);
        return new TypeDescriptor(fqName, safeClassName, members, diagnostics);
    }

    private static (string baseTypeName, bool isNullable, bool isEnum) GetBaseTypeInfo(ITypeSymbol type)
    {
        var isNullable = false;
        var actualType = type;

        if (type is INamedTypeSymbol { IsGenericType: true, Name: "Nullable" } nullable)
        {
            isNullable = true;
            actualType = nullable.TypeArguments[0];
        }

        if (type.NullableAnnotation == NullableAnnotation.Annotated && type.OriginalDefinition.SpecialType == SpecialType.None)
        {
            isNullable = true;
        }

        var isEnum = actualType.TypeKind == TypeKind.Enum;
        var baseTypeName = actualType.ToDisplayString();

        return (baseTypeName, isNullable, isEnum);
    }

    private static string GetAlignmentName(int value)
    {
        return value switch
        {
            0 => "Left",
            1 => "Right",
            2 => "Center",
            3 => "None",
            _ => "Left"
        };
    }

    private static string CreateSetter(string typeName, INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target, object? val) => target.{propertyName} = ({typeName})val!";

    private static string CreateGetter(INamedTypeSymbol type, string propertyName)
        => $"({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} target) => target.{propertyName}";

    private sealed record TypeDescriptor(
        string FullyQualifiedName,
        string SafeClassName,
        IReadOnlyList<MemberDescriptor> Members,
        IReadOnlyList<Diagnostic> Diagnostics);

    private sealed record MemberDescriptor(
        string MemberName,
        int Start,
        int Length,
        char PadChar,
        string Alignment,
        string TypeName,
        string TypeofTypeName,
        string? Format,
        string? SetterFactory,
        string? GetterFactory,
        string BaseTypeName,
        bool IsNullable,
        bool IsEnum);
}
