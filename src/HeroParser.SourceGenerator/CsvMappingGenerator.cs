using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HeroParser.SourceGenerator;

/// <summary>
/// Source generator for zero-allocation CSV type mapping.
/// Generates compile-time field accessors and object instantiation for maximum performance.
/// </summary>
[Generator]
public class CsvMappingGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register for syntax receiver to find types decorated with CSV mapping attributes
        context.RegisterForSyntaxNotifications(() => new CsvMappingSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not CsvMappingSyntaxReceiver receiver)
            return;

        foreach (var candidateClass in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(candidateClass.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidateClass);

            if (classSymbol == null)
                continue;

            // Generate zero-allocation parser for this type
            var source = GenerateParserClass(classSymbol);
            if (!string.IsNullOrEmpty(source))
            {
                context.AddSource($"{classSymbol.Name}_CsvParser.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private string GenerateParserClass(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        var source = $@"// <auto-generated />
using System;
using System.Runtime.CompilerServices;
using HeroParser.Core;

namespace {namespaceName}
{{
    /// <summary>
    /// High-performance zero-allocation parser for {className}.
    /// Generated at compile-time for maximum performance.
    /// </summary>
    public static class {className}CsvParser
    {{
        /// <summary>
        /// Parse CSV record to {className} with zero allocations.
        /// Uses compile-time generated field accessors for maximum performance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static {className} Parse(in CsvRecord record)
        {{
            // TODO: Generate specific field mapping code based on attributes
            // This is a placeholder implementation
            return new {className}();
        }}

        /// <summary>
        /// Get estimated buffer size for parsing operations.
        /// Used for buffer pool optimizations.
        /// </summary>
        public static int EstimatedBufferSize => 1024; // TODO: Calculate based on field types
    }}
}}";

        return source;
    }
}

/// <summary>
/// Syntax receiver to identify classes that need CSV mapping generation.
/// </summary>
internal class CsvMappingSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        // Look for classes with attributes (potential CSV mapping candidates)
        if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
            classDeclaration.AttributeLists.Count > 0)
        {
            CandidateClasses.Add(classDeclaration);
        }
    }
}